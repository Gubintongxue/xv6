# 3.4 硬件对于强隔离的支持

硬件对于强隔离的支持包括了：user/kernel mode和虚拟内存。

用户态、内核态

首先，我们来看一下user/kernel mode，这里会以尽可能全局的视角来介绍，有很多重要的细节在这节课中都不会涉及。

为了支持user/kernel mode，处理器会有两种操作模式，第一种是user mode，第二种是kernel mode。当运行在kernel mode时，CPU可以运行特定权限的指令（privileged instructions）；当运行在user mode时，CPU只能运行普通权限的指令（unprivileged instructions）。

![](<../.gitbook/assets/image (174).png>)

**普通权限的指令都是一些你们熟悉的指令，例如将两个寄存器相加的指令ADD、将两个寄存器相减的指令SUB、跳转指令JRC、BRANCH指令等等。这些都是普通权限指令，所有的应用程序都允许执行这些指令。**

![](<../.gitbook/assets/image (288).png>)

**特殊权限指令主要是一些直接操纵硬件的指令和设置保护的指令，例如设置page table寄存器、关闭时钟中断。**在处理器上有各种各样的状态，操作系统会使用这些状态，但是只能通过特殊权限指令来变更这些状态。

![](<../.gitbook/assets/image (374).png>)

------

### 补充：**user mode**（用户态）和 **kernel mode**（内核态）概念

**user mode**（用户态）和 **kernel mode**（内核态）分别指的是计算机操作系统中的两种不同运行模式。它们之间的主要区别在于访问权限、CPU指令集的使用限制，以及系统资源管理的能力。

#### **1. 用户态（User Mode）**

- **定义：** 用户态是应用程序运行的模式，限制了对系统关键资源（如内存、硬件设备等）的直接访问。
- **特点：**
  - **受限权限：** 用户态不能直接访问硬件设备和系统内存，只能通过系统调用请求内核态的服务。
  - **隔离性：** 如果应用程序崩溃，只影响该应用程序的进程，不会导致系统崩溃。
  - **示例：** 常见的应用程序（如浏览器、文本编辑器）都运行在用户态。
- **转换方式：** 应用程序需要调用操作系统的 **系统调用（syscall）** 来请求执行需要特权的操作，例如文件读取或网络通信。

#### **2. 内核态（Kernel Mode）**

- **定义：** 内核态是操作系统内核运行的模式，具备对所有系统资源的完全控制。
- 特点：
  - **完全权限：** 内核态有权直接访问所有硬件设备、内存、CPU寄存器和其他系统资源。
  - **高风险：** 任何内核态代码的错误都可能导致系统崩溃（kernel panic）。
  - **示例：** 操作系统内核、设备驱动程序、进程管理、内存管理等关键模块都运行在内核态。

#### **用户态和内核态的转换**

- **系统调用（syscall）：** 用户态程序通过系统调用进入内核态，请求内核执行某些受限操作。
- **中断和异常：** 当发生硬件中断（如键盘输入）或异常（如除零错误）时，CPU从用户态切换到内核态处理问题。
- **上下文切换：** 用户态和内核态之间的切换会引入一定的性能开销，称为上下文切换。

#### **总结**

- **用户态（User Mode）**：用于运行普通用户程序，权限受限，隔离性好。
- **内核态（Kernel Mode）**：用于操作系统内核和关键模块的运行，具备完全控制系统的权限。

用户态和内核态的划分确保了系统的稳定性与安全性。通过严格控制对资源的访问，操作系统能防止用户程序意外或恶意地破坏系统。

------

### 补充：

**用户态（User Mode）和内核态（Kernel Mode）** 与 **普通用户（non-root user）和超级用户（root）** 是两个不同层次的概念，尽管它们之间存在一定的关联，但并不是直接对应的。我们来分别分析这两组概念以及它们的关系：

------

#### **1. 用户态 vs. 内核态**

- **用户态（User Mode）：**
  - 指的是程序在非特权模式下运行，无法直接访问硬件资源和系统核心功能。
  - 应用程序（如文本编辑器、浏览器）和用户空间服务都运行在用户态。
  - **限制：** 用户态需要通过**系统调用**进入内核态才能执行关键操作。
- **内核态（Kernel Mode）：**
  - 操作系统的内核和驱动程序在内核态运行，拥有对系统资源的完全控制权限。
  - CPU在内核态下可以直接访问硬件和关键资源，例如内存、I/O设备。
  - **示例：** 进程管理、内存管理、文件系统和网络协议栈都在内核态运行。

#### **2. 普通用户 vs. root 用户**

- **普通用户（non-root user）：**
  - **普通用户权限受限**，只能操作特定文件和系统资源，例如个人的主目录文件或受限的网络访问。
  - **示例：** 用户账户创建的文件通常归用户所有，且普通用户无法修改系统配置或安装软件。
- **root 用户（超级用户）：**
  - **root** 拥有系统最高权限，能够访问、修改系统的所有资源和文件。
  - root 用户能够执行诸如安装软件、启动/停止系统服务、修改系统配置等操作。
  - **示例：** 在 Linux 系统中，`sudo` 命令让普通用户临时获取 root 权限来执行特权操作。

#### **3. 两者的关系与区别**

| **层次**     | **用户态 vs. 内核态**                    | **普通用户 vs. root**                       |
| ------------ | ---------------------------------------- | ------------------------------------------- |
| **概念**     | 描述的是程序在 CPU 中的运行模式          | 描述的是系统用户的权限级别                  |
| **权限范围** | 用户态受限于系统调用，内核态有完全控制权 | 普通用户权限有限，root 拥有系统最高权限     |
| **执行主体** | 程序、服务或内核进程                     | 操作系统中的用户账户                        |
| **典型场景** | 浏览器在用户态运行，内存管理在内核态运行 | root 可以安装软件，普通用户无法修改系统配置 |

#### **4. 常见误解澄清**

1. **root 用户并不直接对应内核态**。虽然 root 用户拥有最高权限，但他在操作系统中执行命令时，仍是在 **用户态** 中运行。只有通过系统调用或驱动程序等机制，root 才能间接触发进入 **内核态**。
2. **普通用户也能调用内核态功能**。即使是普通用户账户，也可以通过应用程序（如访问文件、使用网络）触发系统调用，由内核态来执行实际的操作。区别在于，某些特权操作（如安装驱动程序或管理服务）只有 root 能够触发。

#### **总结**

- **用户态/内核态** 是程序运行时的 CPU 模式划分，侧重于程序与系统资源的交互。
- **普通用户/root** 是系统账户的权限划分，决定了用户能否访问和管理系统资源。

它们是不同的概念，但存在一定的关联：root 用户有权执行的很多操作（如启动内核模块、修改系统配置）最终都会通过系统调用进入内核态处理。

------



举个例子，当一个应用程序尝试执行一条特殊权限指令，因为不允许在user mode执行特殊权限指令，处理器会拒绝执行这条指令。通常来说，这时会将控制权限从user mode切换到kernel mode，当操作系统拿到控制权之后，或许会杀掉进程，因为应用程序执行了不该执行的指令。

### 特殊权限指令

==下图是RISC-V privilege架构的文档，这个文档包括了所有的特殊权限指令。==在接下来的一个月，你们都会与这些特殊权限指令打交道。我们下节课就会详细介绍其中一些指令。这里我们先对这些指令有一些初步的认识：应用程序不应该执行这些指令，这些指令只能被内核执行。

![](<../.gitbook/assets/image (250).png>)

这里是硬件支持强隔离的一个方面。

### 学生提问

### flag/bit控制mode,改变bit需要特殊权限指令

> 学生提问：如果kernel mode允许一些指令的执行，user mode不允许一些指令的执行，那么是谁在检查当前的mode并实际运行这些指令，并且怎么知道当前是不是kernel mode？是有什么标志位吗？
>
> Frans教授：==是的，在处理器里面有一个flag。在处理器的一个bit，当它为1的时候是user mode，当它为0时是kernel mode。当处理器在解析指令时，如果指令是特殊权限指令，并且该bit被设置为1，处理器会拒绝执行这条指令，==就像在运算时不能除以0一样。
>
> 同一个学生继续问：所以，唯一的控制方式就是通过某种方式更新了那个bit？
>
> Frans教授：你认为是什么指令更新了那个bit位？是特殊权限指令还是普通权限指令？（等了一会，那个学生没有回答）。==很明显，设置那个bit位的指令必须是特殊权限指令，因为应用程序不应该能够设置那个bit到kernel mode，否则的话应用程序就可以运行各种特殊权限指令了。所以那个bit是被保护的，==这样回答了你的问题吗？

==许多同学都已经知道了，实际上RISC-V还有第三种模式称为machine mode===。在大多数场景下，我们会忽略这种模式，所以我也不太会介绍这种模式。 ==所以实际上我们有三级权限（user/kernel/machine）==，而不是两级(user/kernel)。

> 学生提问：考虑到安全性，所有的用户代码都会通过内核访问硬件，但是有没有可能一个计算机的用户可以随意的操纵内核？
>
> Frans教授：并不会，至少小心的设计就不会发生这种事。或许一些程序会有额外的权限，操作系统也会认可这一点。但是这些额外的权限并不会给每一个用户，比如只有root用户有特定的权限来完成安全相关的操作。
>
> 同一个学生提问：那BIOS呢？BIOS会在操作系统之前运行还是之后？
>
> Frans教授：==BIOS是一段计算机自带的代码，它会先启动，之后它会启动操作系统，所以BIOS需要是一段可被信任的代码，它最好是正确的，且不是恶意的。==
>
> #### 用户程序如何执行特殊权限-触发软中断
>
> 学生提问：之前提到，设置处理器中kernel mode的bit位的指令是一条特殊权限指令，那么一个用户程序怎么才能让内核执行任何内核指令？因为现在切换到kernel mode的指令都是一条特殊权限指令了，对于用户程序来说也没法修改那个bit位。
>
> Frans教授：你说的对，这也是我们想要看到的结果。可以这么来看这个问题，首先这里不是完全按照你说的方式工作，在RISC-V中，如果你在用户空间（user space）尝试执行一条特殊权限指令（后面Frans那边的Zoom就断了，等他重新接入，他也没有再继续回答，所以后半段回答是我补充的）==用户程序会通过系统调用来切换到kernel mode。当用户程序执行系统调用，会通过ECALL触发一个软中断（software interrupt），软中断会查询操作系统预先设定的中断向量表，并执行中断向量表中包含的中断处理程序。中断处理程序在内核中，这样就完成了user mode到kernel mode的切换，并执行用户程序想要执行的特殊权限指令。==

### 虚拟内存

我们接下来看看硬件对于支持强隔离性的第二个特性，基本上所有的CPU都支持虚拟内存。

我下节课会更加深入的讨论虚拟内存，这里先简单看一下。基本上来说，处理器包含了page table，而page table将虚拟内存地址与物理内存地址做了对应。

![](<../.gitbook/assets/image (359).png>)

==每一个进程都会有自己独立的page table，这样的话，每一个进程只能访问出现在自己page table中的物理内存。==**操作系统会设置page table，使得每一个进程都有不重合的物理内存，这样一个进程就不能访问其他进程的物理内存，因为其他进程的物理内存都不在它的page table中。**一个进程甚至都不能随意编造一个内存地址，然后通过这个内存地址来访问其他进程的物理内存。这样就给了我们内存的强隔离性。

![](<../.gitbook/assets/image (396).png>)

**基本上来说，page table定义了对于内存的视图，而每一个用户进程都有自己对于内存的独立视图。**这给了我们非常强的内存隔离性。

基于硬件的支持，我们可以重新画一下之前的一张图，我们先画一个矩形，ls程序位于这个矩形中；再画一个矩形，echo程序位于这个矩形中。**每个矩形都有一个虚拟内存地址，从0开始到2的n次方。**

![](<../.gitbook/assets/image (302).png>)

这样，ls程序有了一个内存地址0，echo程序也有了一个内存地址0。但是操作系统会将两个程序的内存地址0映射到不同的物理内存地址，所以ls程序不能访问echo程序的内存，同样echo程序也不能访问ls程序的内存。

类似的，内核位于应用程序下方，假设是XV6，那么它也有自己的内存地址空间，并且与应用程序完全独立。

PS：内核 内存管理相关知识学会后，看这些容易些。
