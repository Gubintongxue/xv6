# 3.6 宏内核 vs 微内核 （Monolithic Kernel vs Micro Kernel）

现在，==我们有了一种方法，可以通过系统调用或者说ECALL指令，将控制权从应用程序转到操作系统中。之后内核负责实现具体的功能并检查参数以确保不会被一些坏的参数所欺骗。==所以内核有时候也被称为可被信任的计算空间（Trusted Computing Base），在一些安全的术语中也被称为TCB。

基本上来说，要被称为TCB，内核首先要是正确且没有Bug的。假设内核中有Bug，攻击者可能会利用那个Bug，并将这个Bug转变成漏洞，这个漏洞使得攻击者可以打破操作系统的隔离性并接管内核。所以内核真的是需要越少的Bug越好（但是谁不是呢）。

![](<../.gitbook/assets/image (379).png>)

==另一方面，内核必须要将用户应用程序或者进程当做是恶意的。==如我之前所说的，内核的设计人员在编写和实现内核代码时，必须要有安全的思想。这个目标很难实现，因为当你的操作系统变得足够大的时候，很多事情就不是那么直观了。你知道的，几乎每一个你用过的或者被广泛使用的操作系统，时不时的都有一个安全漏洞。就算被修复了，但是过了一段时间，又会出现一个新的漏洞。我们之后会介绍为什么很难让所有部分都正确工作，但是你要知道是内核需要做一些tricky的工作，需要操纵硬件，需要非常小心做检查，所以很容易就出现一些小的疏漏，进而触发一个Bug。这也是可以理解的。

![](<../.gitbook/assets/image (392).png>)

一个有趣的问题是，什么程序应该运行在kernel mode？**敏感的代码肯定是运行在kernel mode，因为这是Trusted Computing Base。**

对于这个问题的一个答案是，首先我们会有user/kernel边界，在上面是应用程序，在下面是运行在kernel mode的程序。

![](<../.gitbook/assets/image (351).png>)

### 宏内核介绍

其中一个选项是让整个操作系统代码都运行在kernel mode。大多数的Unix操作系统实现都运行在kernel mode。比如，==XV6中，所有的操作系统服务都在kernel mode中，这种形式被称为Monolithic Kernel Design（[宏内核](https://en.wikipedia.org/wiki/Monolithic\_kernel)）。==

![](<../.gitbook/assets/image (268).png>)

这里有几件事情需要注意：

* 首先，如果考虑Bug的话，这种方式不太好。在一个宏内核中，任何一个操作系统的Bug都有可能成为漏洞。因为我们现在在内核中运行了一个巨大的操作系统，出现Bug的可能性更大了。你们可以去查一些统计信息，平均每3000行代码都会有几个Bug，所以如果有许多行代码运行在内核中，那么出现严重Bug的可能性也变得更大。==所以从安全的角度来说，在内核中有大量的代码是宏内核的缺点。==
* 另一方面，如果你去看一个操作系统，它包含了各种各样的组成部分，比如说文件系统，虚拟内存，进程管理，这些都是操作系统内实现了特定功能的子模块。==宏内核的优势在于，因为这些子模块现在都位于同一个程序中，它们可以紧密的集成在一起，这样的集成提供很好的性能。例如Linux，它就有很不错的性能。==

上面是对于内核的一种设计方式。

![](<../.gitbook/assets/image (231).png>)

### 补充：宏内核（Monolithic Kernel）详解

#### 1. **宏内核的定义**

宏内核是一种**操作系统内核设计**，其中操作系统的所有关键服务和模块都运行在**内核态**。这包括文件系统、虚拟内存管理、进程管理、驱动程序、网络协议栈等。这种内核模式使得所有系统组件共享同一个地址空间，并以最高权限（内核模式）运行。

#### 2. **宏内核的结构**

在宏内核设计中，整个操作系统的模块被集成为一个**单一的程序**。不同模块可以彼此之间无缝协作和共享数据，而不需要通过复杂的进程间通信（IPC）。

##### **示例：Linux 内核的结构**

- **文件系统**：负责管理文件的创建、读写和删除。
- **进程管理**：控制进程的调度、创建和销毁。
- **虚拟内存管理**：提供地址空间映射与页面交换机制。
- **设备驱动程序**：用于与硬件交互。

#### 3. **宏内核的特点**

1. **模块紧密集成**：
   - 宏内核将操作系统的所有组件集成在一起。这些模块共享内核态资源，如内存和Page Cache，因此它们之间的**通信和数据共享效率很高**。
2. **系统调用开销低**：
   - 用户程序与内核之间的**交互只需一次用户态与内核态切换**。这意味着在文件系统、虚拟内存和进程调度之间进行操作时开销较小，提升了系统性能。
3. **高性能**：
   - 由于各模块可以直接调用彼此的功能，宏内核在资源密集型任务（如数据库和文件系统操作）上表现更好。

#### 4. **宏内核的优缺点**

##### **优点**：

- **高性能**：由于系统模块高度集成，减少了模块间通信的开销。
- **资源共享方便**：多个模块可以共享同一缓存（如Page Cache），进一步提升性能。
- **模块之间紧密协作**：虚拟内存系统、文件系统和进程调度模块可以高效协同。

##### **缺点**：

- 安全风险大：
  - **所有代码都在内核态运行**，任何一个模块的Bug都可能导致系统崩溃或安全漏洞。
- 代码量大：
  - 由于所有模块都在内核中，**代码基庞大**，更容易出现Bug。
- 维护复杂：
  - 内核的集成度高，每次修改某个模块都有可能影响其他模块，增加了维护难度。

#### 5. **宏内核的运行示例**

以下是一个简单的系统调用示例，展示如何通过用户态程序调用Linux的内核服务获取进程ID：

```C
#include <stdio.h>
#include <unistd.h>
#include <sys/syscall.h>

int main() {
    // 使用系统调用获取当前进程的 PID
    pid_t pid = syscall(SYS_getpid);
    printf("当前进程的PID是：%d\n", pid);
    return 0;
}
```

**解释**：

- 在该代码中，通过`syscall()`函数请求内核获取进程ID。
- 该操作只需**一次用户态到内核态的切换**，因此执行效率很高。

#### 6. **宏内核的实际应用**

- **Linux**：一个典型的宏内核系统，以其高性能和可扩展性著称。Linux支持服务器、桌面和嵌入式系统。
- **Windows NT内核**：尽管有所优化，但核心设计仍然属于宏内核范畴。

#### 7. **宏内核的适用场景**

- **桌面系统**：如Linux和Windows，它们需要高性能来支持各种用户程序和服务。
- **服务器系统**：数据中心的服务器通常使用Linux宏内核来提供高效的数据处理能力。
- **高性能计算**：需要快速响应和资源共享的环境，如科学计算和数据库系统。

#### 8. **宏内核的设计权衡**

- **性能优先**：宏内核的集成设计使得它在大多数场景下性能优越，但这也带来了**较高的维护和安全成本**。
- **安全性妥协**：为了性能，宏内核在某些方面牺牲了安全性，因为每个模块都运行在高权限的内核态。

#### 9. **总结**

宏内核是一种将操作系统所有模块集中在内核中的设计，其主要优点在于**高性能和高效的模块协作**，但也带来了**更高的Bug风险和安全挑战**。尽管现代操作系统中开始逐步引入一些微内核的理念，但宏内核仍然是大多数桌面系统和服务器系统的主流选择。

------

### 补充：什么服务运行在用户态

在操作系统中，部分服务和程序并不需要在**内核态**运行，而是在**用户态**运行，以确保安全性和模块化设计。这些服务通常是高层次的应用和服务模块。以下是一些典型在**用户态**运行的服务和程序示例：

#### 1. **用户态服务（User-space Services）**

1. **图形用户界面（GUI）服务**
   - **X Window System** 或 **Wayland**（在Linux上）：用于管理窗口、绘制用户界面。
   - **Windows图形界面（如explorer.exe）**：提供桌面环境和文件管理。
2. **守护进程（Daemon Processes）**
   - 这些是后台运行的系统服务，用于完成特定任务。它们可以在用户态中运行，以减少内核态的负担。
     - **sshd**：处理SSH连接。
     - **cron**：定期执行计划任务。
     - **systemd**：用于系统启动和服务管理。
3. **用户应用程序**
   - 所有普通的应用程序均在用户态中运行，包括：
     - **浏览器**（如Chrome、Firefox）
     - **文本编辑器**（如Vim、VSCode）
     - **媒体播放器**（如VLC）

#### 2. **虚拟机与容器**

- **QEMU** 和 **VirtualBox**：这些虚拟机软件主要在用户态运行，它们通过系统调用与内核交互来访问硬件资源。
- **Docker容器**：尽管依赖于内核的隔离机制（如cgroups和namespaces），但容器本身运行在用户态。

#### 3. **文件系统和数据库服务**（部分在用户态运行）

- 有些文件系统和数据库服务设计为

  用户态程序

  ，以避免内核中的复杂性：

  - **FUSE**（Filesystem in Userspace）：允许在用户态开发文件系统。
  - **MySQL、PostgreSQL** 等数据库：通过用户态中的服务进程提供数据存取。

#### 4. **网络服务**

- 某些高层网络服务运行在用户态：
  - **Web服务器**（如Nginx、Apache）：用于处理HTTP请求。
  - **邮件服务器**（如Postfix、Dovecot）：处理电子邮件收发。

#### 5. **开发与调试工具**

- **GDB**：在用户态中运行，用于调试用户程序和部分内核代码。
- **编译器（如GCC、Clang）**：在用户态中工作，用于编译用户程序和内核代码。

#### 6. **部分虚拟内存管理服务**

- **内存映射（mmap）** 和 **swap进程**：尽管核心机制在内核中，但部分内存管理操作是由用户态程序触发的，例如数据库或程序在用户态使用内存映射文件。

#### 7. **安全与认证服务**

- **PAM**（Pluggable Authentication Modules）：提供用户认证，允许管理员在用户态控制用户登录的认证方式。
- **加密服务**：某些高层加密库和安全协议（如OpenSSL）运行在用户态，并通过系统调用与内核态模块交互。

#### 8. **总结**

在操作系统的设计中，**内核态负责底层硬件控制和核心服务**（如进程调度、虚拟内存管理等），而**用户态则负责运行高层次的应用、服务和守护进程**。通过将一些服务放在用户态运行，操作系统可以提高**安全性**（即使用户态程序崩溃也不会影响内核）并**减少内核的复杂性**。

- 核心思路：
  - **用户态**运行的程序不直接接触硬件和系统的核心数据结构，只能通过**系统调用**访问内核服务。
  - 通过这种分离，确保了内核的稳定性和安全性，同时也使得系统更加模块化。

------



### 微内核介绍

另一种设计主要关注点是减少内核中的代码，它被称为Micro Kernel Design（[微内核](https://en.wikipedia.org/wiki/Microkernel)）。在这种模式下，希望在kernel mode中运行尽可能少的代码。所以这种设计下还是有内核，但是内核只有非常少的几个模块，例如，内核通常会有一些IPC的实现或者是Message passing；非常少的虚拟内存的支持，可能只支持了page table；以及分时复用CPU的一些支持。

==微内核的目的在于将大部分的操作系统运行在内核之外。==所以，我们还是会有user mode以及user/kernel mode的边界。==但是我们现在会将原来在内核中的其他部分，作为普通的用户程序来运行。==比如文件系统可能就是个常规的用户空间程序。这个文件系统我不小心画成了红色，其实我想画成黑色的。

![](<../.gitbook/assets/image (372).png>)

现在，**文件系统运行的就像一个普通的用户程序，就像echo，Shell一样，这些程序都运行在用户空间。可能还会有一些其他的用户应用程序，例如虚拟内存系统的一部分也会以一个普通的应用程序的形式运行在user mode。**

![](<../.gitbook/assets/image (277).png>)

某种程度上来说，这是一种好的设计。**因为在内核中的代码的数量较小，更少的代码意味着更少的Bug。**

### 消息来实现传统的系统调用，消息调度在内核

但是这种设计也有相应的问题。假设我们需要让Shell能与文件系统交互，比如Shell调用了exec，必须有种方式可以接入到文件系统中。通常来说，这里工作的方式是，**Shell会通过内核中的IPC系统发送一条消息，内核会查看这条消息并发现这是给文件系统的消息，之后内核会把消息发送给文件系统。**

![](<../.gitbook/assets/image (256).png>)

**文件系统会完成它的工作之后会向IPC系统发送回一条消息说，这是你的exec系统调用的结果，之后IPC系统再将这条消息发送给Shell。**

![](<../.gitbook/assets/image (169).png>)

所以，==这里是典型的通过消息来实现传统的系统调用。==现在，对于任何文件系统的交互，都需要分别完成2次用户空间<->内核空间的跳转。与宏内核对比，在宏内核中如果一个应用程序需要与文件系统交互，只需要完成1次用户空间<->内核空间的跳转，==所以微内核的的跳转是宏内核的两倍。==通常微内核的挑战在于性能更差，这里有两个方面需要考虑：

1. ==在user/kernel mode反复跳转带来的性能损耗。==
2. ==在一个类似宏内核的紧耦合系统，各个组成部分，例如文件系统和虚拟内存系统，可以很容易的共享page cache。而在微内核中，每个部分之间都很好的隔离开了，这种共享更难实现。进而导致更难在微内核中得到更高的性能。==



我们这里介绍的有关宏内核和微内核的区别都特别的笼统。在实际中，两种内核设计都会出现，出于历史原因大部分的桌面操作系统是宏内核，==如果你运行需要大量内核计算的应用程序，例如在数据中心服务器上的操作系统，通常也是使用的宏内核，主要的原因是Linux提供了很好的性能。但是很多嵌入式系统，例如Minix，Cell，这些都是微内核设计。==这两种设计都很流行，如果你从头开始写一个操作系统，你可能会从一个微内核设计开始。但是一旦你有了类似于Linux这样的宏内核设计，将它重写到一个微内核设计将会是巨大的工作。并且这样重构的动机也不足，因为人们总是想把时间花在实现新功能上，而不是重构他们的内核。

所以这里是操作系统的两种主要设计。如你们所知的，XV6是一种宏内核设计，如大多数经典的Unix系统一样。但是在这个学期的后半部分，我们会讨论更多有关微内核设计的内容。

这里有什么问题吗？因为在课前的邮件提问中，这块问的还挺多的。（没人提问）



# 总结

## 3.6 宏内核 vs 微内核（Monolithic Kernel vs Micro Kernel）

### 3.6.1 内核简介：系统调用与可信计算空间 (TCB)

- **系统调用的作用**：
  - 系统调用（ECALL）用于从应用程序转到操作系统的内核，赋予内核控制权来执行特定的操作。
  - 内核需要**检查传递的参数**，确保它们不是恶意的输入。
- **可信计算空间（TCB, Trusted Computing Base）**：
  - TCB指的是系统中的可信部分（通常为内核），必须确保代码尽量**正确且无Bug**。
  - **Bug与漏洞的关联**：如果内核代码中存在漏洞，攻击者可能会通过这些漏洞突破系统隔离，获得控制权。

------

### 3.6.2 内核设计的核心挑战

1. **安全性挑战**：
   - **假设用户程序是恶意的**：内核在设计和实现时必须预防来自用户态程序的恶意行为。
   - **复杂性与安全性冲突**：操作系统越复杂，漏洞也会越多。
   - 主流操作系统经常会发现和修复漏洞，但始终难以保证完全安全。
2. **Bug的不可避免性**：
   - 根据统计数据：**平均每3000行代码中就可能存在多个Bug**。
   - **代码越多**，漏洞越多，这对操作系统的安全性提出了严峻挑战。

### 3.6.3 内核模式与用户模式的区分

- **内核态**：用于运行系统的核心功能代码，必须是高度可信且安全的模块。
- **用户态**：用于执行普通应用程序。
- **边界划分**：不同的内核设计通过不同方式划分用户态与内核态的职责。

### 3.6.4 宏内核设计（Monolithic Kernel）

#### 3.6.4.1 定义与架构

- **宏内核**：所有的系统模块，包括文件系统、虚拟内存管理和进程管理等，均运行于**内核态**。
- **实例**：Unix系统（如Linux、XV6）即为典型的宏内核。

#### 3.6.4.2 宏内核的特点

- **优点**：
  - **高性能**：紧密集成的系统模块（如文件系统和虚拟内存）共享资源（如Page Cache），减少数据复制的开销。
  - **系统调用效率高**：程序和内核之间的交互只需**一次用户态与内核态切换**。
- **缺点**：
  - **Bug影响面广**：任何系统模块的Bug都可能危及整个内核的稳定性。
  - **代码量大**：更多的代码意味着潜在漏洞增多，从而增加攻击面。

#### 3.6.4.3 宏内核设计示例：Linux 系统调用

以下是宏内核下的一个简单的系统调用示例：

```
#include <stdio.h>
#include <unistd.h>
#include <sys/syscall.h>

int main() {
    // 使用系统调用 sys_getpid 获取当前进程 ID
    pid_t pid = syscall(SYS_getpid);
    printf("Current PID: %d\n", pid);
    return 0;
}
```

**说明**：

- 该代码调用`syscall()`，直接与内核进行交互。
- **用户态到内核态的切换**：仅需一次切换，即可完成进程ID的查询。

### 3.6.5 微内核设计（Micro Kernel）

#### 3.6.5.1 定义与架构

- **微内核**：将大部分系统模块移出内核，仅保留少数关键模块（如IPC和基本虚拟内存支持）在内核中运行。

#### 3.6.5.2 微内核的特点

- **优点**：
  - **代码量小**：减少内核中的代码意味着**减少漏洞**的可能性。
  - **模块化**：系统模块在用户空间中运行，出现Bug时不会影响内核的稳定性。
- **缺点**：
  - **性能损耗**：频繁的用户态与内核态切换导致性能下降。
  - **模块间共享困难**：如Page Cache在不同模块之间的共享变得更加复杂。

#### 3.6.5.3 微内核设计的示例

#### Shell与文件系统交互的消息传递示例：

1. **Shell进程**：用户在Shell中执行`exec`命令，调用文件系统来启动程序。
2. 消息传递流程：
   - Shell通过IPC发送消息给内核，内核将消息转发给文件系统。
   - 文件系统处理完后，将结果通过IPC返回给内核，内核再传递给Shell。

伪代码示例：

```C
// 伪代码展示 Shell 和文件系统的消息交互
void shell_exec(const char *command) {
    // 发送消息给内核，请求文件系统执行命令
    ipc_send_to_kernel("EXEC", command);
}

void kernel_ipc_handler(const char *message) {
    // 内核接收到消息并转发给文件系统
    ipc_send_to_filesystem(message);
}

void filesystem_handler(const char *message) {
    // 文件系统处理命令并返回结果
    ipc_send_to_kernel("RESULT", "Success");
}
```

**说明**：

- 该示例展示了微内核中的**多次用户态与内核态切换**：从Shell到内核，再到文件系统，需要**两次切换**。
- 与宏内核相比，这种多次切换导致性能开销增加。

### 3.6.6 宏内核与微内核的性能对比

1. **用户态与内核态的切换**：
   - **宏内核**：只需一次切换完成文件系统操作。
   - **微内核**：需要多次切换，带来更高的开销。
2. **资源共享的效率**：
   - **宏内核**：模块之间紧密集成，易于共享缓存（如Page Cache）。
   - **微内核**：模块之间隔离性强，导致共享资源的效率较低。

### 3.6.7 实际应用场景

- **宏内核的应用**：
  - 桌面操作系统（如Linux）和数据中心服务器系统采用宏内核，以确保性能和资源管理的高效性。
- **微内核的应用**：
  - 嵌入式系统（如Minix、Cell）采用微内核设计，注重安全性和模块隔离。

### 3.6.8 设计权衡与发展趋势

- **宏内核的优势**：性能优越、模块紧密集成。
- **微内核的优势**：安全性高、易于隔离模块。
- **现代操作系统的趋势**：
  - 多数现代操作系统融合了两种设计的优点，尽量减少内核中的代码量，同时保持高性能。

### 3.6.9 总结

- **设计选择的影响**：
  - 如果从头开始开发操作系统，通常会选择微内核设计作为起点，但将宏内核系统重构为微内核系统成本过高，且动力不足。
- **课程安排**：
  - 在本学期后半部分，将深入探讨微内核的设计和实现。

### 3.6.10 课堂问答

- **课前问题总结**：根据课前的邮件反馈，同学们对宏内核和微内核的设计区别有较多疑问，但在课堂上未收到进一步提问。

这个版本更加详细地涵盖了讲课的所有要点，提供了具体的代码示例和流程说明，帮助理解微内核与宏内核的区别和性能差异。希望这次的总结符合你的预期！



