# 6.1 Trap机制

今天我想讨论一下，程序运行时完成用户空间和内核空间的切换。每当

* 程序执行系统调用
* 程序出现了类似page fault、运算时除以0的错误
* 一个设备触发了中断使得当前程序运行需要响应内核设备驱动

都会发生这样的切换 。

这里用户空间和内核空间的切换通常被称为trap，而trap涉及了许多小心的设计和重要的细节，这些细节对于实现安全隔离和性能来说非常重要。**因为很多应用程序，要么因为系统调用，要么因为page fault，都会频繁的切换到内核中。所以，trap机制要尽可能的简单，这一点非常重要。**

初始的场景你们已经非常熟悉了。我们有一些用户应用程序，例如Shell，它运行在用户空间，同时我们还有内核空间。Shell可能会执行系统调用，将程序运行切换到内核。比如XV6启动之后Shell输出的一些提示信息，就是通过执行write系统调用来输出的。这是Shell尝试执行wrtie系统调用的一个例子。

![](<../.gitbook/assets/image (243).png>)

我们需要清楚如何让程序的运行，从只拥有user权限并且位于用户空间的Shell，切换到拥有supervisor权限的内核。==在这个过程中，硬件的状态将会非常重要，因为我们很多的工作都是将硬件从适合运行用户应用程序的状态，改变到适合运行内核代码的状态。==

我们最关心的状态可能是32个用户寄存器，这在上节课中有介绍。RISC-V总共有32个比如a0，a1这样的寄存器，用户应用程序可以使用全部的寄存器，并且使用寄存器的指令性能是最好的。

![](<../.gitbook/assets/image (327).png>)

这里的很多寄存器都有特殊的作用，我们之后都会看到。其中一个特别有意思的寄存器是stack pointer（也叫做堆栈寄存器 stack register）。所以，我们有了包含堆栈寄存器在内的这32个寄存器。

此外，

* 在硬件中还有一个寄存器叫做程序计数器（Program Counter Register）。
* 表明当前mode的标志位，这个标志位表明了当前是supervisor mode还是user mode。当我们在运行Shell的时候，自然是在user mode。
* 还有一堆控制CPU工作方式的寄存器，比如SATP（Supervisor Address Translation and Protection）寄存器，它包含了指向page table的物理内存地址（详见4.3）。
* 还有一些对于今天讨论非常重要的寄存器，比如STVEC（Supervisor Trap Vector Base Address Register）寄存器，它指向了内核中处理trap的指令的起始地址。
* SEPC（Supervisor Exception Program Counter）寄存器，在trap的过程中保存程序计数器的值。
* SSRATCH（Supervisor Scratch Register）寄存器，这也是个非常重要的寄存器（详见6.5）。

这些寄存器表明了执行系统调用时计算机的状态。

![](<../.gitbook/assets/image (221).png>)

### trap处理过程

可以肯定的是，==在trap的最开始，CPU的所有状态都设置成运行用户代码而不是内核代码。==在trap处理的过程中，我们实际上需要更改一些这里的状态，或者对状态做一些操作。这样我们才可以运行系统内核中普通的C程序。接下来我们先来预览一下需要做的操作：

* ==首先，我们需要保存32个用户寄存器。==因为很显然我们需要恢复用户应用程序的执行，尤其是当用户程序随机的被设备中断所打断时。我们希望内核能够响应中断，之后在用户程序完全无感知的情况下再恢复用户代码的执行。所以这意味着32个用户寄存器不能被内核弄乱。但是这些寄存器又要被内核代码所使用，所以在trap之前，你必须先在某处保存这32个用户寄存器。
* 程序计数器也需要在某个地方保存，它几乎跟一个用户寄存器的地位是一样的，我们需要能够在用户程序运行中断的位置继续执行用户程序。
* ==我们需要将mode改成supervisor mode，==因为我们想要使用内核中的各种各样的特权指令。
* ==SATP寄存器现在正指向user page table==，而user page table只包含了用户程序所需要的内存映射和一两个其他的映射，它并没有包含整个内核数据的内存映射。==所以在运行内核代码之前，我们需要将SATP指向kernel page table。==
* ==我们需要将堆栈寄存器指向位于内核的一个地址==，因为我们需要一个堆栈来调用内核的C函数。
* 一旦我们设置好了，并且所有的硬件状态都适合在内核中使用， ==我们需要跳入内核的C代码==。



一旦我们运行在内核的C代码中，那就跟平常的C代码是一样的。之后我们会讨论内核通过C代码做了什么工作，但是今天的讨论是如何从将程序执行从用户空间切换到内核的一个位置，这样我们才能运行内核的C代码。

### **如何从将程序执行从用户空间切换到内核的一个位置**

#### 不依赖用户空间东西

操作系统的一些high-level的目标能帮我们过滤一些实现选项。其中一个目标是安全和隔离，我们不想让用户代码介入到这里的user/kernel切换，否则有可能会破坏安全性。所以这意味着，trap中涉及到的硬件和内核机制不能依赖任何来自用户空间东西。**比如说我们不能依赖32个用户寄存器，它们可能保存的是恶意的数据，所以，XV6的trap机制不会查看这些寄存器，而只是将它们保存起来。**

#### 隔离性、透明性

在操作系统的trap机制中，我们仍然想保留隔离性并防御来自用户代码的可能的恶意攻击。同样也很重要的是，另一方面，我们想要让trap机制对用户代码是透明的，也就是说我们想要执行trap，然后在内核中执行代码，同时用户代码并不用察觉到任何有意思的事情。这样也更容易写用户代码。

#### 安全

需要注意的是，虽然我们这里关心隔离和安全，但是今天我们只会讨论从用户空间切换到内核空间相关的安全问题。当然，系统调用的具体实现，比如说write在内核的具体实现，以及内核中任何的代码，也必须小心并安全的写好。所以，即使从用户空间到内核空间的切换十分安全，整个内核的其他部分也必须非常安全，并时刻小心用户代码可能会尝试欺骗它。

#### mode标志位

在前面介绍的寄存器中，有一个特殊的寄存器我想讨论一下，也就是mode标志位。这里的mode表明当前是user mode还是supervisor mode。当然，当我们在用户空间时，这个标志位对应的是user mode，当我们在内核空间时，这个标志位对应supervisor mode。但是有一点很重要：当这个标志位从user mode变更到supervisor mode时，我们能得到什么样的权限。实际上，这里获得的额外权限实在是有限。也就是说，你可以在supervisor mode完成，但是不能在user mode完成的工作，或许并没有你想象的那么有特权。所以，我们接下来看看supervisor mode可以控制什么？

#### supervisor mode->读写控制寄存器->使用PTE_U标志位为0的PTE

其中的一件事情是，你现在可以读写控制寄存器了。比如说，当你在supervisor mode时，你可以：读写SATP寄存器，也就是page table的指针；STVEC，也就是处理trap的内核指令地址；SEPC，保存当发生trap时的程序计数器；SSCRATCH等等。在supervisor mode你可以读写这些寄存器，而用户代码不能做这样的操作。

另一件事情supervisor mode可以做的是，它可以使用PTE\_U标志位为0的PTE。当PTE\_U标志位为1的时候，表明用户代码可以使用这个页表；==如果这个标志位为0，则只有supervisor mode可以使用这个页表。==我们接下来会看一下为什么这很重要。

这两点就是supervisor mode可以做的事情，除此之外就不能再干别的事情了。

![](<../.gitbook/assets/image (389).png>)

#### supervisor mode->不能读写任意物理地址，需要页表，受限虚拟地址

==需要特别指出的是，supervisor mode中的代码并不能读写任意物理地址。==在supervisor mode中，就像普通的用户代码一样，也需要通过page table来访问内存。如果一个虚拟地址并不在当前由SATP指向的page table中，又或者SATP指向的page table中PTE\_U=1，那么supervisor mode不能使用那个地址。所以，即使我们在supervisor mode，==我们还是受限于当前page table设置的虚拟地址。==

所以，这就是全部了。在supervisor我们只能做这些事情，我们接下来会看一下，当我们进入到内核空间时，trap代码的执行流程。



------



# 6.1 Trap机制详细总结

## 一、什么是Trap机制？

Trap 是指 **从用户空间切换到内核空间** 的过程，可能触发trap的情况包括：

1. **系统调用**：程序请求内核提供的服务，如 `write`。
2. **异常**：如 **page fault** 或除以 0 等运算错误。
3. **中断**：来自外部设备的中断，需要内核驱动处理。

## 二、Trap的重要性和设计原则

- **高效性**：trap 机制必须**简单且高效**，因为系统调用和中断会**频繁**发生。
- **隔离与安全**：trap 机制需要确保用户空间与内核空间之间的**隔离**，防止用户代码干扰内核。
- **透明性**：trap 机制对用户代码是**透明**的，即用户不需要关心trap的具体实现。

## 三、Trap的基本结构

1. **用户空间**运行应用程序，如 `Shell`。
2. **内核空间**处理系统调用和中断。

在trap发生时，程序状态需要从**用户模式**切换为**内核模式**，这涉及到：

- **寄存器状态**的保存和恢复
- **mode（模式）** 的切换（从 user mode 到 supervisor mode）
- **堆栈指针**的切换（从用户栈到内核栈）

## 四、关键寄存器

1. **32个用户寄存器**：如 `a0`, `a1`，这些寄存器在用户空间中使用。
2. **控制寄存器**：
   - **程序计数器（PC）**：记录当前指令的地址。
   - **SATP（Supervisor Address Translation and Protection）**：指向当前使用的page table。
   - **STVEC**：指向trap处理代码的起始地址。
   - **SEPC**：保存发生trap时的程序计数器（PC）的值。
   - **SSCRATCH**：供内核trap处理时临时使用的寄存器。

## 五、Trap处理流程概览

==在trap发生时，需要进行以下步骤：==

1. **保存32个用户寄存器**：保证在trap结束后可以恢复用户程序的执行。
2. **保存程序计数器（PC）**：确保trap结束后从正确位置继续执行用户程序。
3. **切换为supervisor mode**：获取内核所需的特权操作权限。
4. **更新SATP寄存器**：从**用户page table**切换为**内核page table**。
5. **切换堆栈指针**：将**用户栈**切换为**内核栈**。
6. **跳转到内核的C代码**：内核开始处理系统调用或中断。

## 六、Trap中的安全性与隔离

- **内核隔离用户数据**：
  - XV6中的trap机制不依赖用户寄存器的内容，避免用户代码提供恶意数据。
  - **用户寄存器的内容会直接保存**，不会立即使用。
- **Supervised Mode（内核模式）**权限：
  - 在supervisor mode中，内核可以：
    1. 读写控制寄存器（如 `SATP`、`STVEC` 等）。
    2. 使用 **PTE_U** 标志位为0的内存页面（表示只有内核可以访问）。
- **地址空间受限**：
  - **即使在supervisor mode**，内核也只能访问**当前page table**中映射的虚拟地址，无法随意操作任意物理地址。

## 七、Mode标志位的切换与权限

- **用户模式（user mode）**：普通用户代码运行，限制特权操作。
- ==内核模式（supervisor mode）：==
  - 可以操作控制寄存器（如 `SATP`、`SEPC` 等）。
  - 访问 PTE_U 为 0 的内存页面（内核专属页面）。
  - 需要通过page table进行地址访问。

即使处于内核模式，内核代码依然**受限于page table的地址映射**，不能直接访问所有物理地址。

## 八、Trap示例：系统调用与中断

- **系统调用**：
  - 例如：`Shell` 调用 `write` 系统调用输出信息。
  - 程序从 **用户空间** 切换到 **内核空间**，调用内核代码执行系统调用。
- **中断处理**：
  - 如外部设备的中断信号。
  - 内核捕获中断并执行中断处理程序。

## 九、总结

1. Trap机制的流程与挑战

- **寄存器状态**的保存和恢复确保程序能无缝继续执行。
- **mode切换**确保内核代码具备必要的权限，但依然受限于page table的地址映射。
- **Trap的安全性与透明性**：确保用户代码不会干扰内核，同时对用户代码透明。

### 2. XV6中的Trap设计

- **简单且高效**：trap机制保持尽量简洁，以提高性能。
- **隔离与安全**：避免用户代码对内核的干扰，确保系统的稳定性。
- **基于page table的访问限制**：内核只能访问映射到当前page table的虚拟地址。

通过本节的学习，学生能够理解 **trap的基本原理和实现细节**，以及如何在RISC-V架构中实现用户空间与内核空间的切换。这些知识在实验中至关重要，特别是在 **系统调用** 和 **中断处理** 相关的实验中。

------



## 拓展

### 补充：**CPU 执行的是机器码**，也就是**二进制指令**，它是经过汇编和链接后的最终结果。

### **程序执行的完整流程**

#### 1. **源代码 (.c / .cpp / .s)**

- 你首先写的程序可能是 **C**、**C++** 或 **汇编**语言。

#### 2. **编译 (Compiler)**

- **C / C++** 代码会被编译器（如 `gcc`、`clang`）编译成 **汇编代码 (.s)**。

- 例如：

  ```
  mov rax, 10     # 将 10 加载到 rax 寄存器
  add rax, 5      # 将 5 加到 rax
  ```

#### 3. **汇编 (Assembler)**

- 汇编器（如 as）将汇编代码转换为机器码，生成 目标文件 (.o)。.o 文件中包含：

  - **机器码**
  - **符号表**：用于记录未解析的外部函数和变量
  - **元数据**：用于链接器解析

#### 4. **链接 (Linker)**

- 链接器（如 `ld`）将多个 **.o 文件** 和 **库文件** 合并，生成一个完整的 **可执行文件**（如 ELF 文件）。

- 可执行文件中包含：

   - **机器码**（CPU 直接运行的部分）
  - **程序入口地址**：告诉 CPU 从哪里开始执行
  - **符号表**（可能用于调试）
  - **段信息**（如代码段、数据段、BSS 段等）

#### 5. **加载 (Loader)**

- 当操作系统加载一个可执行文件时，Loader会：

  1. 将程序的代码段和数据段加载到内存中。
  2. 设置堆栈、堆等数据结构。
  3. 将 **程序入口地址**（如 `main()`）交给 CPU。

### **CPU 执行的是机器码**

- **CPU 执行的是真正的机器码**，也就是由汇编器生成的 **二进制指令**。

- 机器码是以 

  二进制格式

  存储的，如：

  - `1011 0001 0000 0000` 表示一个 **RISC-V** 或 **x86** 指令。

#### **示例：x86 机器码**

以下汇编代码：

```
mov rax, 10
add rax, 5
```

会被转换成如下机器码（用十六进制表示）：

```
48 C7 C0 0A 00 00 00  ; mov rax, 10
48 83 C0 05           ; add rax, 5
```

------

### *可执行文件和机器码的关系**

- **可执行文件 (.out / ELF / EXE)** 包含了 **机器码** 和其他元数据。
- 当 **Loader** 将可执行文件加载到内存后，**CPU 从内存中读取机器码并逐条执行**。

### **总结**

- **.o 文件** 中包含了机器码和符号表，用于链接阶段。
- **CPU 直接执行的是机器码**（二进制指令）。
- **可执行文件**（如 ELF）是一个容器，包含了机器码和元数据，用于操作系统加载和管理。

------



### ==补充：那为什么CPU不直接使用.o文件，还要进行链接==

这是因为**`.o` 文件只是目标文件**，它并不包含程序完整的执行内容。以下是详细解释，为什么 **CPU 无法直接执行 `.o` 文件**，而需要链接生成一个 **完整的可执行文件**。

### **1. `.o` 文件的结构与问题**

- **`.o` 文件**（目标文件）是由编译器将 **源代码** 转换成的**机器码的片段**，但它**不是完整的程序**。
  **原因：**

  - 目标文件通常只包含部分代码，比如某个 **函数的实现**。
  - 里面会存在 **未定义的符号**（如外部函数或全局变量），这些符号需要在链接阶段解析。

  **示例：**

  ```C
  // file1.c
  extern int add(int, int);  // 引用外部函数
  int main() {
      return add(2, 3);
  }
  ```

  - 编译 `file1.c` 后的 `.o` 文件里，**add()** 函数的实现还不存在，只是一个未解析的符号。

### 2. 链接的必要性：解决符号和依赖

链接器的任务是将所有 **目标文件和库文件组合在一起**，解决符号和依赖问题，生成一个**完整的可执行文件**。链接器做了以下工作：

1. **符号解析**

   - 解析目标文件中未定义的符号。例如，将 `add()` 的实现与 `main()` 的调用链接起来。

   **示例：**

   ```C
   // file2.c
   int add(int a, int b) {
       return a + b;
   }
   ```

   在链接阶段，链接器会将 `file1.o` 和 `file2.o` 合并，将 `add()` 的实现与 `main()` 中的调用关联。

2. **地址重定位**

   - 每个目标文件中的函数和变量在编译时都**不知道自己的最终地址**。链接器会为它们分配内存地址，并在最终生成的可执行文件中填入正确的地址。

3. **库的合并**

   - 例如，当程序使用标准库函数（如 `printf()`），链接器会将相关库（如 `libc`）中的实现代码加入到可执行文件中。

### 3. 目标文件与可执行文件的区别

| **属性**       | **.o 文件**          | **可执行文件（ELF/EXE）**     |
| -------------- | -------------------- | ----------------------------- |
| **内容**       | 部分机器码和符号表   | 完整的机器码和元数据          |
| **符号解析**   | 未解析所有符号       | 所有符号已解析                |
| **地址重定位** | 代码片段的地址待定   | 代码片段和变量的地址已确定    |
| **库依赖**     | 需要链接器引入外部库 | 包含所有必要的库和依赖        |
| **是否可执行** | 不能直接执行         | 可以直接加载到内存由 CPU 执行 |

### **4. 示例：未解析符号导致无法直接执行 `.o` 文件**

假设我们有两个文件：

- file1.c：

  ```C
  extern int add(int, int);
  int main() {
      return add(2, 3);
  }
  ```

- file2.c：

  ```C
  int add(int a, int b) {
      return a + b;
  }
  ```

编译每个文件：

```sh
gcc -c file1.c  # 生成 file1.o
gcc -c file2.c  # 生成 file2.o
```

如果你试图直接执行 `file1.o`，会报错，因为它的符号 `add()` 还没有解析。我们需要将两个 `.o` 文件链接在一起：

```sh
gcc file1.o file2.o -o program
```

`program` 是一个完整的可执行文件，可以直接运行。

### 5. 机器码与内存布局

- **目标文件中的机器码** 是**未重定位的片段**，缺少地址和内存布局的信息。
- 链接器将目标文件的机器码合并，并分配内存地址，确保程序的各部分（代码段、数据段、堆栈等）正确布局在内存中。

### 6. 链接优化：减少依赖和冗余

- **静态链接**：将所有依赖的库代码直接嵌入可执行文件。
- **动态链接**：在程序运行时加载共享库（如 `.so` 文件），减少可执行文件的大小。

### **7. 总结**

- **CPU 无法直接执行 `.o` 文件**，因为 `.o` 文件只是部分机器码，还包含未解析的符号和未重定位的地址。
- **链接器的任务** 是将多个目标文件和库文件组合在一起，解析符号、重定位地址，生成一个完整的可执行文件。
- **可执行文件** 是 CPU 真正运行的最终产物，里面包含了所有的机器码和元数据，确保程序可以正确加载和执行。

------

