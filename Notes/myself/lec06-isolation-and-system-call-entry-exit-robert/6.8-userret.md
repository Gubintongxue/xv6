# 6.8 userret函数

现在程序执行又到了trampoline代码。

![](<../.gitbook/assets/image (796).png>)

第一步是切换page table。在执行_csrw satp, a1_之前，page table应该还是巨大的kernel page table。这条指令会将user page table（在usertrapret中作为第二个参数传递给了这里的userret函数，所以存在a1寄存器中）存储在SATP寄存器中。执行完这条指令之后，page table就变成了小得多的user page table。但是幸运的是，user page table也映射了trampoline page，所以程序还能继续执行而不是崩溃。（注，sfence.vma是清空页表缓存，详见4.4）。

![](<../.gitbook/assets/image (717).png>)

在uservec函数中，第一件事情就是交换SSRATCH和a0寄存器。而这里，我们将SSCRATCH寄存器恢复成保存好的用户的a0寄存器。在这里a0是trapframe的地址，因为C代码usertrapret函数中将trapframe地址作为第一个参数传递过来了。112是a0寄存器在trapframe中的位置。（注，这里有点绕，本质就是通过当前的a0寄存器找出存在trapframe中的a0寄存器）我们先将这个地址里的数值保存在t0寄存器中，之后再将t0寄存器的数值保存在SSCRATCH寄存器中。

为止目前，所有的寄存器内容还是属于内核。

![](<../.gitbook/assets/image (741).png>)

接下来的这些指令将a0寄存器指向的trapframe中，之前保存的寄存器的值加载到对应的各个寄存器中。之后，我们离能真正运行用户代码就很近了。

> 学生提问：现在trapframe中的a0寄存器是我们执行系统调用的返回值吗？
>
> Robert教授：是的，系统调用的返回值覆盖了我们保存在trapframe中的a0寄存器的值（详见6.6）。我们希望用户程序Shell在a0寄存器中看到系统调用的返回值。所以，trapframe中的a0寄存器现在是系统调用的返回值2。相应的SSCRATCH寄存器中的数值也应该是2，可以通过打印寄存器的值来验证。

![](<../.gitbook/assets/image (701).png>)

现在我们打印所有的寄存器，

![](<../.gitbook/assets/image (743).png>)

我不确定你们是否还记得，但是这些寄存器的值就是我们在最最开始看到的用户寄存器的值。例如SP寄存器保存的是user stack地址，这是一个在较小的内存地址；a1寄存器是我们传递给write的buffer指针，a2是我们传递给write函数的写入字节数。

a0寄存器现在还是个例外，它现在仍然是指向trapframe的指针，而不是保存了的用户数据。

![](<../.gitbook/assets/image (873).png>)

接下来，在我们即将返回到用户空间之前，我们交换SSCRATCH寄存器和a0寄存器的值。前面我们看过了SSCRATCH现在的值是系统调用的返回值2，a0寄存器是trapframe的地址。交换完成之后，a0持有的是系统调用的返回值，SSCRATCH持有的是trapframe的地址。之后trapframe的地址会一直保存在SSCRATCH中，直到用户程序执行了另一次trap。现在我们还在kernel中。

sret是我们在kernel中的最后一条指令，当我执行完这条指令：

* 程序会切换回user mode
* SEPC寄存器的数值会被拷贝到PC寄存器（程序计数器）
* 重新打开中断

现在我们回到了用户空间。打印PC寄存器，

![](<../.gitbook/assets/image (715).png>)

这是一个较小的指令地址，非常像是在用户内存中。如果我们查看sh.asm，可以看到这个地址是write函数的ret指令地址。

![](<../.gitbook/assets/image (645).png>)

所以，现在我们回到了用户空间，执行完ret指令之后我们就可以从write系统调用返回到Shell中了。或者更严格的说，是从触发了系统调用的write库函数中返回到Shell中。

> 学生提问：你可以再重复一下在sret过程中，中断会发生什么吗？
>
> Robert教授：sret打开了中断。所以在supervisor mode中的最后一个指令，我们会重新打开中断。用户程序可能会运行很长时间，最好是能在这段时间响应例如磁盘中断。

最后总结一下，系统调用被刻意设计的看起来像是函数调用，但是背后的user/kernel转换比函数调用要复杂的多。之所以这么复杂，很大一部分原因是要保持user/kernel之间的隔离性，内核不能信任来自用户空间的任何内容。

另一方面，XV6实现trap的方式比较特殊，XV6并不关心性能。但是通常来说，操作系统的设计人员和CPU设计人员非常关心如何提升trap的效率和速度。必然还有跟我们这里不一样的方式来实现trap，当你在实现的时候，可以从以下几个问题出发：

* 硬件和软件需要协同工作，你可能需要重新设计XV6，重新设计RISC-V来使得这里的处理流程更加简单，更加快速。
* 另一个需要时刻记住的问题是，恶意软件是否能滥用这里的机制来打破隔离性。

好的，这就是这节课的全部内容。



# **6.8 userret 函数：从内核返回用户空间的最后一步**

`userret` 函数位于 **trampoline.s** 文件中，是操作系统从内核空间安全返回到用户空间的最后一步。在 `userret` 函数中，系统完成 **页表切换**、**寄存器恢复**，并执行 **sret 指令** 将程序切换回用户模式。

## 1. 切换到用户页表

- 执行 `_csrw satp, a1_` 指令：
  - **a1 寄存器**：包含用户页表的地址。
  - **效果**：将用户页表地址写入 **SATP 寄存器**，切换到 **用户页表**。
  - **注意**：切换后，系统仍然能够执行 trampoline 页中的代码，因为 trampoline 页在用户页表和内核页表中映射一致。
  - **sfence.vma**：清空页表缓存，确保新的页表生效。

## **2. 恢复 SSCRATCH 和 a0 寄存器**

- **交换 SSCRATCH 和 a0 寄存器的内容**：
  - **操作**：将 **SSCRATCH** 中保存的 **用户 a0** 寄存器内容恢复出来（即系统调用返回值），并将 **trapframe 地址** 放入 **SSCRATCH** 中。

## **3. 恢复用户寄存器**

- 将用户寄存器的值从 trapframe 中加载回实际的寄存器：

  - **目的**：确保用户程序恢复执行时，所有寄存器的状态与调用系统调用前一致。

  **a0 寄存器**：

  - 现在保存的值是 **系统调用的返回值**，之前在内核中 `sys_write` 的返回值为 2。

## **4. 打印寄存器，验证数据**

- 打印恢复后的寄存器：
  - 可以看到 **SP** 指向用户栈地址（较小的内存地址），**a1** 和 **a2** 也保存了 write 函数的参数。
  - **a0 寄存器**：保存系统调用返回值 2。

## **5. 交换 SSCRATCH 和 a0**

- 再次交换 **SSCRATCH** 和 **a0**：
  - **a0**：现在保存的是系统调用返回值 2。
  - **SSCRATCH**：现在保存的是 **trapframe 地址**，为下一次触发 trap 做准备。

## **6. 执行 sret 指令，返回用户空间**

- 执行 **sret 指令**：
  - **sret 的作用**：
    1. 将程序计数器（PC）设置为 SEPC 寄存器中的值（即用户程序的下一条指令）。
    2. 打开中断。
    3. 切换到 **user mode**。
  - **验证**：执行 sret 后，我们查看程序计数器的值：
    - 地址指向了用户程序中 write 函数的 **ret 指令**，表明系统调用已经完成，程序即将返回到 Shell。

## **7. 回到用户空间**

- **write 系统调用**完成后，用户程序继续执行：
  - Shell 中的 **write 库函数**返回，程序返回到 Shell 主循环，等待用户的下一次输入。

## **8. 中断机制与 sret 的关系**

- 学生提问：sret 执行时，中断会发生什么？
  - Robert 教授回答：
    - 执行 **sret** 后会打开中断。在用户程序运行时，如果有设备中断（例如磁盘中断），程序可以及时响应。

## **9. 总结**

`userret` 函数通过一系列汇编指令，实现了从内核到用户空间的安全切换：

1. **页表切换**：切换到用户页表，确保虚拟地址空间正确映射。
2. **寄存器恢复**：从 trapframe 中恢复所有用户寄存器。
3. **系统调用返回值传递**：将系统调用的返回值写入 a0 寄存器，供用户程序使用。
4. **执行 sret 指令**：切换回 **user mode** 并启用中断。

### **操作系统设计的挑战**

- **系统调用的复杂性**：系统调用看似简单，但需要实现安全且高效的 **user/kernel** 切换。
- 设计权衡：
  1. **隔离性**：内核不信任用户空间的任何内容。
  2. **性能优化**：高效的 trap 实现可以减少用户和内核之间的切换开销。

通过这些机制，`XV6` 实现了基本但安全的系统调用框架，为用户程序与内核之间的交互提供了支持。
