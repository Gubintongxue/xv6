# 6.4 ECALL指令之后的状态

### 执行ecall->打印程序计数器PC查看地址->查看page table->page table暂时不变

现在我执行ecall指令，

![](<../.gitbook/assets/image (173).png>)

第一个问题，执行完了ecall之后我们现在在哪？我们可以打印程序计数器（Program Counter）来查看。

![](<../.gitbook/assets/image (316) (1) (1) (1) (1).png>)

可以看到程序计数器的值变化了，之前我们的程序计数器还在一个很小的地址0xde6，但是现在在一个大得多的地址。

==我们还可以查看page table，我通过在QEMU中执行info mem来查看当前的page table，可以看出，这还是与之前完全相同的page table，所以page table没有改变。==

![](<../.gitbook/assets/image (349).png>)



根据现在的程序计数器，代码正在trampoline page的最开始，这是用户内存中一个非常大的地址。所以现在我们的指令正运行在内存的trampoline page中。我们可以来查看一下现在将要运行的指令。

![](<../.gitbook/assets/image (775).png>)



这些指令是内核在supervisor mode中将要执行的最开始的几条指令，也是在trap机制中最开始要执行的几条指令。因为gdb有一些奇怪的行为，我们实际上已经执行了位于trampoline page最开始的一条指令（注，也就是csrrw指令），我们将要执行的是第二条指令。

#### 寄存器暂时没有改变

我们可以查看寄存器，对比6.3中的图可以看出，寄存器的值并没有改变，这里还是用户程序拥有的一些寄存器内容。

![](<../.gitbook/assets/image (776).png>)



所以，现在寄存器里面还都是用户程序的数据，并且这些数据也还只保存在这些寄存器中，所以我们需要非常小心，在将寄存器数据保存在某处之前，我们在这个时间点不能使用任何寄存器，否则的话我们是没法恢复寄存器数据的。==如果内核在这个时间点使用了任何一个寄存器，内核会覆盖寄存器内的用户数据，之后如果我们尝试要恢复用户程序，我们就不能恢复寄存器中的正确数据，用户程序的执行也会相应的出错。==

### 学生提问

> 学生提问：我想知道csrrw指令是干什么的？
>
> Robert教授：我们过几分钟会讨论这部分。但是对于你的问题的答案是，==这条指令交换了寄存器a0和sscratch的内容。==这个操作超级重要，它回答了这个问题，内核的trap代码如何能够在不使用任何寄存器的前提下做任何操作。这条指令将a0的数据保存在了sscratch中，同时又将sscratch内的数据保存在a0中。之后内核就可以任意的使用a0寄存器了。



我们现在在这个地址0x3ffffff000，也就是上面page table输出的最后一个page，这是trampoline page。我们现在正在trampoline page中执行程序，这个page包含了内核的trap处理代码。

#### ecall不会切换page table->trap存在于每一个user page table

==ecall并不会切换page table，这是ecall指令的一个非常重要的特点。==所以这意味着，trap处理代码必须存在于每一个user page table中。因为ecall并不会切换page table，我们需要在user page table中的某个地方来执行最初的内核代码。

==而这个trampoline page，是由内核小心的映射到每一个user page table中，以使得当我们仍然在使用user page table时，内核在一个地方能够执行trap机制的最开始的一些指令。==

#### STVEC寄存器控制->trampoline映射到每一个user page table，起始地址->trap从此地址执行

**这里的控制是通过STVEC寄存器完成的，这是一个只能在supervisor mode下读写的特权寄存器。在从内核空间进入到用户空间之前，内核会设置好STVEC寄存器指向内核希望trap代码运行的位置。**

![](<../.gitbook/assets/image (709).png>)



所以如你所见，内核已经事先设置好了STVEC寄存器的内容为0x3ffffff000，**这就是trampoline page的起始位置**。STVEC寄存器的内容，**就是在ecall指令执行之后，我们会在这个特定地址执行指令的原因。**

#### trampoline page PTE没有设置PTE_u标志，用户无法写

最后，我想提示你们，即使trampoline page是在用户地址空间的user page table完成的映射，用户代码不能写它，因为这些page对应的PTE并没有设置PTE\_u标志位。这也是为什么trap机制是安全的。

#### PC在trampoline page执行代码，但程序没有崩溃->正在supervisor mode

我一直在告诉你们我们现在已经在supervisor mode了，但是实际上我并没有任何能直接确认当前在哪种mode下的方法。不过我的确发现程序计数器现在正在trampoline page执行代码，而这些page对应的PTE并没有设置PTE\_u标志位。所以现在只有当代码在supervisor mode时，才可能在程序运行的同时而不崩溃。所以，我从代码没有崩溃和程序计数器的值推导出我们必然在supervisor mode。

### ecall实际上只会改变三件事情

我们是通过ecall走到trampoline page的，而==ecall实际上只会改变三件事情：==

==第一，ecall将代码从user mode改到supervisor mode。==

==第二，ecall将程序计数器的值保存在了SEPC寄存器。我们可以通过打印程序计数器看到这里的效果，==

![](<../.gitbook/assets/image (316) (1).png>)

尽管其他的寄存器还是还是用户寄存器，但是这里的程序计数器明显已经不是用户代码的程序计数器。这里的程序计数器是从STVEC寄存器拷贝过来的值。我们也可以打印SEPC（Supervisor Exception Program Counter）寄存器，这是ecall保存用户程序计数器的地方。

![](<../.gitbook/assets/image (829).png>)

这个寄存器里面有熟悉的地址0xde6，这是ecall指令在用户空间的地址。所以ecall至少保存了程序计数器的数值。

==第三，ecall会跳转到STVEC寄存器指向的指令。==

### ecall之后执行步骤

所以现在，ecall帮我们做了一点点工作，但是实际上我们离执行内核中的C代码还差的很远。接下来：

* 我们需要保存32个用户寄存器的内容，这样当我们想要恢复用户代码执行时，我们才能恢复这些寄存器的内容。
* 因为现在我们还在user page table，我们需要切换到kernel page table。
* 我们需要创建或者找到一个kernel stack，并将Stack Pointer寄存器的内容指向那个kernel stack。这样才能给C代码提供栈。
* 我们还需要跳转到内核中C代码的某些合理的位置。

ecall并不会为我们做这里的任何一件事。

### 为什么ecall不做更多的事

当然，我们可以通过修改硬件让ecall为我们完成这些工作，而不是交给软件来完成。并且，我们也将会看到，在软件中完成这些工作并不是特别简单。所以你现在就会问，为**什么ecall不多做点工作来将代码执行从用户空间切换到内核空间呢？为什么ecall不会保存用户寄存器，或者切换page table指针来指向kernel page table，或者自动的设置Stack Pointer指向kernel stack，或者直接跳转到kernel的C代码，而不是在这里运行复杂的汇编代码？**

#### 灵活性

实际上，有的机器在执行系统调用时，会在硬件中完成所有这些工作。但是RISC-V并不会，RISC-V秉持了这样一个观点：ecall只完成尽量少必须要完成的工作，其他的工作都交给软件完成。这里的原因是，RISC-V设计者想要为软件和操作系统的程序员提供最大的灵活性，这样他们就能按照他们想要的方式开发操作系统。所以你可以这样想，尽管XV6并没有使用这里提供的灵活性，但是一些其他的操作系统用到了。

* 举个例子，因为这里的ecall是如此的简单，或许某些操作系统可以在不切换page table的前提下，执行部分系统调用。切换page table的代价比较高，如果ecall打包完成了这部分工作，那就不能对一些系统调用进行改进，使其不用在不必要的场景切换page table。
* 某些操作系统同时将user和kernel的虚拟地址映射到一个page table中，这样在user和kernel之间切换时根本就不用切换page table。对于这样的操作系统来说，如果ecall切换了page table那将会是一种浪费，并且也减慢了程序的运行。
* 或许在一些系统调用过程中，一些寄存器不用保存，而哪些寄存器需要保存，哪些不需要，取决于于软件，编程语言，和编译器。通过不保存所有的32个寄存器或许可以节省大量的程序运行时间，所以你不会想要ecall迫使你保存所有的寄存器。
* 最后，对于某些简单的系统调用或许根本就不需要任何stack，所以对于一些非常关注性能的操作系统，ecall不会自动为你完成stack切换是极好的。

所以，**ecall尽量的简单可以提升软件设计的灵活性**。

### 学生提问

（以下问答来自于视频60:00处，因为相关就移过来了）

> 学生提问：为什么我们在gdb中看不到ecall的具体内容？或许我错过了，但是我觉得我们是直接跳到trampoline代码的。
>
> Robert教授：ecall只会更新CPU中的mode标志位为supervisor，并且设置程序计数器成STVEC寄存器内的值。在进入到用户空间之前，内核会将trampoline page的地址存在STVEC寄存器中。所以ecall的下一条指令的位置是STVEC指向的地址，也就是trampoline page的起始地址。==（注，实际上ecall是CPU的指令，自然在gdb中看不到具体内容）==

------



## 拓展

### 补充：**在 GDB 中使用 `x/6i 0x3ffffff000` 的含义**

#### **1. 命令的结构解析：**

在 GDB（GNU Debugger）中，`x` 是一个非常常用的命令，用于**检查内存内容**。这个命令格式如下：

```
x/[数量][格式] [地址]
```

- **x**：表示内存检查命令。
- /6i：
  - **6**：表示显示**6 条指令**。
  - **i**：表示以**反汇编指令的形式（instruction）**显示内容。
- **0x3ffffff000**：这是一个具体的**内存地址**，用于指定从该地址开始显示指令。

------

#### **2. 命令的含义：**

`x/6i 0x3ffffff000` 的意思是：

- **从地址 0x3ffffff000 开始**，显示 **6 条汇编指令**。
- GDB 会尝试将从该地址开始的内存内容解释为**机器指令**，并将它们**反汇编成汇编代码**，便于用户查看和调试。

------

#### **3. 可能的应用场景：**

1. **调试程序中的指令**：
   - 如果你知道某个函数或跳转的位置在内存的地址 `0x3ffffff000` 附近，可以用此命令查看从这个位置开始的汇编指令，以分析程序的执行逻辑。
2. **排查错误或分析跳转指令**：
   - 当程序崩溃或行为异常时，使用此命令可以检查某些关键内存位置的代码，判断是否出现了错误的跳转或修改。
3. **分析动态库或特定函数**：
   - 某些程序在调试时可能会涉及特定的内存地址范围，此时可以通过此命令查看该位置的具体指令。

------

#### **4. 示例输出：**

假设内存地址 `0x3ffffff000` 存在一些机器指令，那么输出可能类似于：

```
0x3ffffff000:  push   %rbp
0x3ffffff001:  mov    %rsp, %rbp
0x3ffffff004:  sub    $0x10, %rsp
0x3ffffff008:  mov    $0x0, %eax
0x3ffffff00d:  add    $0x1, %eax
0x3ffffff010:  ret
```

- 在这个示例中，GDB 从 `0x3ffffff000` 地址开始，显示了 **6 条汇编指令**，帮助开发人员理解程序的执行逻辑。

------

#### **5. 总结：**

`x/6i 0x3ffffff000` 是 GDB 中用于查看特定内存地址处的**反汇编指令**的命令。它有助于开发人员检查从该地址开始的代码逻辑，尤其在调试和排查问题时非常有用。

------



### 补充：**什么是 Trampoline Page？**

**Trampoline Page** 是一种在操作系统内核设计中的特殊机制，用于在用户态和内核态之间**安全跳转**。它本质上是一段位于特定内存页中的代码，帮助从用户态切换到内核态（或反之），尤其是在处理系统调用、异常或中断时。这种设计确保了系统能够安全、高效地完成模式切换，避免在地址转换过程中出现错误或安全漏洞。

### **Trampoline Page 的用途**

1. **用户态到内核态的转换**：
   - 当用户程序发出**系统调用**或遇到**异常/中断**时，处理器需要从**用户态**切换到**内核态**。此时，Trampoline Page 充当一个“跳板”（trampoline），将 CPU 的控制权转交给内核的处理逻辑。
2. **处理地址转换问题**：
   - **内存分页**和**虚拟地址空间**是现代操作系统的重要部分。为了保证用户态和内核态之间的切换不会因为分页问题或地址访问权限问题而失败，Trampoline Page 使用特殊的内存区域。这些区域在**用户进程的虚拟地址空间**和**内核地址空间**中都可访问，确保了转换的顺畅。
3. **中断和异常处理**：
   - 当系统发生硬件中断或软件异常时，CPU 需要立刻跳转到内核的处理程序。这时，Trampoline Page 提供了一段安全的代码路径，从当前进程的上下文跳转到内核的异常处理逻辑。
4. **上下文保存与恢复**：
   - Trampoline Page 在模式切换时保存当前进程的状态（如寄存器值）并设置新的上下文。在返回用户态时，Trampoline Page 会从保存的上下文中恢复状态，保证程序的正常执行。

### **Trampoline Page 的实现细节**

- **位置**：通常，Trampoline Page 被映射到内存中的**高地址段**（例如，`0xFFFF...`），该地址在用户和内核的地址空间中都可访问。
- **映射方式**：Trampoline Page 的内存映射是特殊的，即使在**不同的页表**之间切换时，这部分代码的地址也保持一致。这保证了即使发生页表切换，CPU 也能正确找到 Trampoline Page 代码的位置。
- **示例**：在 RISC-V 的内核中，Trampoline Page 用于从用户进程跳转到内核异常处理程序。通常，这段代码与 `satp`（Supervisor Address Translation and Protection）寄存器配合使用，确保切换后的页表生效。

### **为什么需要 Trampoline Page？**

1. **解决页表切换问题**：
   当用户进程切换到内核时，系统通常需要切换页表。Trampoline Page 的设计保证了即使页表切换期间，也不会因地址不可访问而导致程序崩溃。
2. **提高安全性**：
   通过将切换逻辑集中在一个安全的内存区域内，避免了恶意代码的干扰，增强了系统的安全性。
3. **简化切换逻辑**：
   Trampoline Page 充当了模式转换的桥梁，使得操作系统的设计更清晰。所有用户态到内核态的切换都经过这段代码，方便管理和维护。

### **总结**

Trampoline Page 是操作系统中的一个重要机制，主要用于在用户态和内核态之间**安全高效地切换**。它解决了页表切换时的地址访问问题，并确保了异常处理和系统调用的稳定性。通过这种设计，操作系统可以在不同的特权级别之间进行无缝的上下文切换。

------







# **6.4 ECALL指令之后的状态**

本节深入分析了 **ECALL 指令** 执行后的状态，包括程序如何进入内核的 `trampoline` 代码，并讲解了系统调用从用户态切换到内核态的初步处理流程。我们还探讨了为什么 **RISC-V** 的设计选择允许操作系统灵活管理这些切换步骤。

------

## **ECALL 指令的执行**

1. **执行 ECALL 指令**
   - 在执行 `ecall` 指令后，我们打印 **程序计数器（PC）** 的值，发现地址从 **0xde6（用户态）** 跳转到了一个 **较大的地址**（0x3ffffff000），这是 **trampoline page** 的起始位置。
2. **查看当前 Page Table**
   - 通过 QEMU 的 **`info mem`** 命令确认 **page table**。我们发现当前的 page table 和 ECALL 之前完全相同。这表明 **ECALL 本身不会触发 page table 切换**。

------

## **进入 Trampoline Page**

1. **代码运行在 Trampoline Page**
   - ECALL 指令后，执行的第一批指令位于 **trampoline page**。这些指令是内核在 **supervisor mode** 下处理 trap 的第一部分代码。
2. **寄存器状态未变**
   - 检查寄存器内容后发现，它们依然保存着用户程序的数据。这意味着在寄存器数据未保存之前，**内核代码不能任意使用这些寄存器**，否则会破坏用户态的数据，导致恢复失败。

------

## **CSRRW 指令的作用**

1. **CSRRW 指令**
   - 这条指令将寄存器 **a0** 与 **sscratch** 寄存器的内容互换，允许内核安全地使用 a0 而不破坏用户数据。这是内核在寄存器未保存的情况下执行初始操作的重要机制。
2. **为何在 Trampoline Page 运行代码？**
   - 由于 **ECALL 不会切换 page table**，所以内核代码必须运行在用户 page table 中映射的 **trampoline page** 上。这确保了在 ECALL 触发的 trap 开始时，内核能执行初始代码。
3. **STVEC 寄存器**
   - **STVEC 寄存器** 存储着跳转到 trampoline page 的地址。在用户态切换到内核态之前，内核会提前设置 **STVEC** 指向 trampoline page 的起始地址（0x3ffffff000）。

------

## **ECALL 指令的具体效果**

ECALL 指令完成了三件事情：

1. **将模式从 User Mode 切换为 Supervisor Mode**
   - 这是实现用户态到内核态切换的重要步骤，允许执行内核代码。
2. **保存用户态的 PC 到 SEPC 寄存器**
   - **SEPC 寄存器** 存储了触发 ECALL 时的用户态 PC 地址。我们通过 gdb 检查 SEPC，发现它存储的地址正是用户态的 **0xde6**。
3. **跳转到 STVEC 指向的地址**
   - ECALL 结束后，程序跳转到 **trampoline page**（由 STVEC 指向）。

## **为什么 ECALL 的设计保持简化？**

1. **设计者的灵活性考虑**
   - **RISC-V** 选择了让 **ECALL 只完成最基本的工作**，剩下的交给软件管理。这为操作系统提供了更多的自由度来决定如何处理系统调用。
2. **灵活性带来的优势**
   - **避免不必要的 page table 切换**：某些系统调用可能无需切换 page table。
   - **结合用户和内核地址空间的优化**：一些操作系统将用户态和内核态映射在同一个 page table 中，不需要频繁切换。
   - **按需保存寄存器**：某些系统调用只需保存部分寄存器，减少不必要的性能开销。
   - **无需自动切换栈**：对于简单系统调用，不需要强制切换到内核栈，进一步提升性能。

## 总结：ECALL 的设计权衡

- **ECALL 只完成必要的三件事**：切换模式、保存 PC、跳转到 trampoline page。
- 这种设计提供了极大的灵活性，但同时也将复杂性转移给了操作系统。这让不同的操作系统可以根据自己的需求优化 **trap 处理** 流程，而不受硬件限制。
- **提问与回答**
  - 问题：为什么 gdb 无法看到 ECALL 的详细内容？
    - **回答**：ECALL 是 CPU 指令，不是软件代码。==它只更新 CPU 中的 **mode 标志位**，设置 **PC 为 STVEC 的值**，然后跳转到 trampoline page。==因此，gdb 中无法展示 ECALL 的具体执行内容。

## **下一步：从 Trampoline 进入内核代码**

- ==ECALL 只完成了基础切换工作，但要运行内核的 C 代码，还有更多步骤需要完成：==
  - **保存 32 个用户寄存器** 以便后续恢复。
  - **切换到内核 page table**。
  - **设置 Stack Pointer（SP）指向内核栈**。
  - **跳转到内核中的 C 代码**。

这些步骤都需要通过软件来完成。在接下来的课程中，我们将深入探讨如何从 **trampoline page** 完成这些工作，并顺利进入内核的 C 代码执行流程。

