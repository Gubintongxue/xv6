# 6.2 Trap代码执行流程

我首先会简单介绍一下trap代码的执行流程，但是这节课大部分时间都会通过gdb来跟踪代码是如何通过trap进入到内核空间，这里会涉及到很多的细节。

### write->ecall->uservec

为了帮助你提前了解接下来的内容，我们会跟踪如何在Shell中调用write系统调用。

==从Shell的角度来说，这就是个Shell代码中的C函数调用，但是实际上，write通过执行ECALL指令来执行系统调用。==ECALL指令会切换到具有supervisor mode的内核中。在这个过程中，内核中执行的第一个指令是一个由汇编语言写的函数，叫做uservec。这个函数是内核代码trampoline.s文件的一部分。所以执行的第一个代码就是这个uservec汇编函数。

![](<../.gitbook/assets/image (220).png>)

### ->usertrap

之后，在这个汇编函数中，代码执行跳转到了由C语言实现的函数usertrap中，这个函数在trap.c中。

![](<../.gitbook/assets/image (235).png>)

### ->syscall->sys_write

现在代码运行在C中，所以代码更加容易理解。在usertrap这个C函数中，我们执行了一个叫做syscall的函数。

![](<../.gitbook/assets/image (216).png>)

这个函数会在一个表单中，==根据传入的代表系统调用的数字进行查找，并在内核中执行具体实现了系统调用功能的函数。对于我们来说，这个函数就是sys\_write。==

![](<../.gitbook/assets/image (332).png>)

sys\_write会将要显示数据输出到console上，当它完成了之后，它会返回给syscall函数。

![](<../.gitbook/assets/image (295).png>)

因为我们现在相当于在ECALL之后中断了用户代码的执行，为了用户空间的代码恢复执行，需要做一系列的事情。

### usertrapret->返回到用户空间

在syscall函数中，会调用一个函数叫做usertrapret，它也位于trap.c中，这个函数完成了部分方便在C代码中实现的返回到用户空间的工作。

![](<../.gitbook/assets/image (273).png>)

除此之外，最终还有一些工作只能在汇编语言中完成。**这部分工作通过汇编语言实现，并且存在于trampoline.s文件中的userret函数中。**

![](<../.gitbook/assets/image (403).png>)

最终，在这个汇编函数中会调用机器指令返回到用户空间，并且恢复ECALL之后的用户程序的执行。

![](<../.gitbook/assets/image (364).png>)

### 学生提问

对于这里的概述大家有问题吗？没有的话我要切到gdb了。

### user page table -> kernel page table

> 学生提问：vm.c运行在什么mode下？
>
> Robert教授：vm.c中的所有函数都是内核的一部分，所以运行在supervisor mode。
>
> 学生提问：为什么这些函数叫这些名字？
>
> Robert教授：现在的函数命名比较乱，明年我会让它们变得更加合理一些。（助教说）我认为命名与寄存器的名字有关。
>
> 学生提问：难道vm.c里的函数不是要直接访问物理内存吗？
>
> Robert教授：是的，这些函数能这么做的原因是，内核小心的在page table中设置好了各个PTE。这样当内核收到了一个读写虚拟内存地址的请求，会通过kernel page table将这个虚拟内存地址翻译成与之等价物理内存地址，再完成读写。所以，==一旦使用了kernel page table，就可以非常方便的在内核中使用所有这些直接的映射关系。但是直到trap机制切换到内核之前，这些映射关系都不可用。直到trap机制将程序运行切换到内核空间之前，我们使用的仍然是没有这些方便映射关系的user page table。==
>
> 学生提问：这个问题或许并不完全相关，read和write系统调用，相比内存的读写，他们的代价都高的多，因为它们需要切换模式，并来回捣腾。==有没有可能当你执行打开一个文件的系统调用时， 直接得到一个page table映射，而不是返回一个文件描述符？==这样只需要向对应于设备的特定的地址写数据，程序就能通过page table访问特定的设备。你可以设置好限制，就像文件描述符只允许修改特定文件一样，这样就不用像系统调用一样在用户空间和内核空间来回捣腾了。

### mmap机制

> Robert教授：这是个很好的想法。==实际上很多操作系统都提供这种叫做内存映射文件（Memory-mapped file access）的机制，在这个机制里面通过page table，可以将用户空间的虚拟地址空间，对应到文件内容，这样你就可以通过内存地址直接读写文件。实际上，你们将在mmap 实验中完成这个机制。==对于许多程序来说，这个机制的确会比直接调用read/write系统调用要快的多。



------



# **6.2 Trap代码执行流程**

本节详细讲解了操作系统如何通过 **trap 机制** 从用户空间切换到内核空间，并执行具体的系统调用。重点是通过 **`write` 系统调用** 展示这一流程，并跟踪代码执行路径及底层细节。以下是详细的 trap 代码执行流程分析及相关问题解答。

------

## **Trap 代码的完整执行路径**

1. **用户程序调用系统调用（write）**
   - 在 **Shell** 程序中，用户调用 `write` 函数来输出数据。这是一个 **C 函数调用**，但实际上，这个调用会触发 **ECALL 指令**，切换到内核态。
2. **执行 ECALL 指令，进入内核空间**
   - ECALL 指令将 **CPU 模式** 从 **用户态 (user mode)** 切换为 **内核态 (supervisor mode)**，标志着进入内核空间。
3. **uservec 汇编代码的执行**
   - 切换到内核态后，控制权交给 **`uservec`** 函数（汇编实现，位于 `trampoline.s` 文件）。`uservec` 是 ECALL 触发后的第一个执行的汇编指令，负责保存用户态寄存器状态并初始化内核栈。
4. **跳转到 C 语言实现的 `usertrap` 函数**
   - **`uservec`** 汇编函数完成初始化后，将执行流程转交给 C 实现的 **`usertrap`** 函数（在 `trap.c` 中），这是内核处理中断或系统调用的入口。
5. **执行 `syscall` 函数，定位具体系统调用**
   - 在 **`usertrap`** 中，系统调用由 **`syscall`** 函数处理。`syscall` 根据系统调用编号查找对应的实现函数。对于 **write** 系统调用，它会找到并执行 **`sys_write`** 函数。
6. **执行 `sys_write`，完成具体输出**
   - **`sys_write`** 会将传入的数据写入到 **console** 中。任务完成后，`sys_write` 返回给 **`syscall`**，表示系统调用的处理结束。
7. **调用 `usertrapret` 函数，准备返回用户态**
   - 在完成系统调用后，**`usertrapret`** 函数负责恢复部分寄存器状态，并为从内核返回到用户态做准备。
8. **执行汇编函数 `userret`，最终返回用户态**
   - 部分操作只能由汇编完成，因此 `usertrapret` 会调用 **`userret`**（在 `trampoline.s` 中）。
   - 在 **`userret`** 中使用 **`sret` 指令**，将 CPU 模式切换回 **用户态**，并恢复执行 ECALL 之后的用户程序。

------

## **Trap 执行路径总结**

- **进入内核**：`uservec`（汇编） → `usertrap`（C 语言）
- **执行系统调用**：`syscall` → `sys_write`
- **恢复用户态**：`usertrapret`（C 语言） → `userret`（汇编）

------

## **学生问答及进一步讨论**

1. **vm.c 代码在什么模式下运行？**
   - **Robert教授**：`vm.c` 中的所有代码都运行在 **supervisor mode**（内核态），因为这些代码属于内核空间。
2. **vm.c 中的函数如何访问物理内存？**
   - **Robert教授**：在内核中，**kernel page table** 映射了虚拟地址与物理地址的对应关系，因此内核代码可以通过访问虚拟地址来操作物理内存。只有在进入内核后，才能使用这些映射。
3. **系统调用的性能问题：是否可以直接映射内存？**
   - **学生**：系统调用涉及频繁的 **用户态-内核态** 切换，代价较高。能否通过 **page table** 直接映射文件内容，而不是使用文件描述符？
   - **Robert教授**：这是一个不错的想法。很多操作系统提供了 **内存映射文件（Memory-mapped file access）** 的功能，这样可以通过直接访问内存地址来读写文件数据。你们在之后的 **mmap 实验** 中将会实现类似的机制。这种机制通常比直接使用系统调用更高效。

------

## **关键点分析**

### 1. **内核与用户态的隔离**

- 用户态程序和内核代码使用不同的 **page table**，用户态只能访问 **PTE_U=1** 的内存，而内核态可以访问 **PTE_U=0** 的内存。
- 在进入内核空间前，CPU 使用的是 **user page table**。进入内核后，CPU 会切换到 **kernel page table**，这样才能操作内核数据。

### 2. **Page Table 切换的重要性**

- 当系统调用触发 **ECALL** 后，系统会切换到 **内核 page table**，确保内核能访问所需的内存区域并执行操作。

### 3. **用户态与内核态的寄存器管理**

- **用户寄存器** 在 `uservec` 汇编代码中保存，以确保系统调用完成后能无缝恢复用户程序的状态。

------

## **总结**

- 本节详细描述了 **trap 机制** 的实现：如何从 **用户态** 进入 **内核态**，执行系统调用，并最终返回到用户程序的执行路径。
- **内核态和用户态的 Page Table 切换** 是实现内存隔离和权限控制的关键。操作系统通过 **trap 机制** 实现安全的上下文切换，确保用户程序无法直接干扰内核数据。
- **gdb 调试工具** 在跟踪系统调用路径和分析寄存器状态时非常有用，可以帮助深入理解内核和用户程序之间的交互。

这就是 6.2 节中关于 **trap 代码执行流程** 的全部内容。
