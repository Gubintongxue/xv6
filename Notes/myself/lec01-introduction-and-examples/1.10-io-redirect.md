# 1.10 I/O Redirect

最后一个例子，我想展示一下将所有这些工具结合在一起，来实现I/O重定向。

![](<../.gitbook/assets/image (362).png>)

我们之前讲过，Shell提供了方便的I/O重定向工具。如果我运行下面的指令，

![](<../.gitbook/assets/image (387).png>)

Shell会将echo的输出送到文件out。之后我们可以运行cat指令，并将out文件作为输入，

![](<../.gitbook/assets/image (397).png>)

我们可以看到保存在out文件中的内容就是echo指令的输出。

### fork后在子进程改变文件描述符，不影响父进程输入输出

Shell之所以有这样的能力，是因为Shell首先会像第13行一样fork，==然后在子进程中，Shell改变了文件描述符。==文件描述符1通常是进程用来作为输出的（也就是console的输出文件符），Shell会将文件描述符1改为output文件，之后再运行你的指令。同时，父进程的文件描述符1并没有改变。==所以这里先fork，再更改子进程的文件描述符，是Unix中的常见的用来重定向指令的输入输出的方法，这种方法同时又不会影响父进程的输入输出。==因为我们不会想要重定向Shell的输出，我们只想重定向子进程的输出。

这里之所以能工作的原因是，代码的第15行只会在子进程中执行。代码的第15行的意义是重定向echo命令的输出，如果我运行整个程序redirect程序。

![](<../.gitbook/assets/image (294).png>)

可以看到没有任何的输出。但是实际上redirect程序里面运行了echo，只是echo的输出重定向到了output.txt。如果我们查看output.txt，

![](<../.gitbook/assets/image (337).png>)

我们可以看到预期的输出。代码第15行的close(1)的意义是，我们希望文件描述符1指向一个其他的位置。也就是说，在子进程中，我们不想使用原本指向console输出的文件描述符1。

代码第16行的open一定会返回1，因为open会返回当前进程未使用的最小文件描述符序号。因为我们刚刚关闭了文件描述符1，而文件描述符0还对应着console的输入，所以open一定可以返回1。在代码第16行之后，文件描述符1与文件output.txt关联。

之后我们执行exec(echo)，echo会输出到文件描述符1，也就是文件output.txt。这里有意思的地方是，echo根本不知道发生了什么，echo也没有必要知道I/O重定向了，它只是将自己的输出写到了文件描述符1。只有Shell知道I/O重定向了。

这个例子同时也演示了分离fork和exec的好处。fork和exec是分开的系统调用，意味着在子进程中有一段时间，fork返回了，但是exec还没有执行，子进程仍然在运行父进程的指令。所以这段时间，尽管指令是运行在子进程中，但是这些指令仍然是父进程的指令，所以父进程仍然可以改变东西，直到代码执行到了第19行。这里fork和exec之间的间隔，提供了Shell修改文件描述符的可能。

------

### 补充：代码分析

这段代码展示了如何通过**fork**和**exec**系统调用实现I/O重定向。下面我会逐步解释它的逻辑以及关键操作：

```C
int pid;

pid = fork(); // 第一次分支：创建子进程
if (pid == 0) { // 子进程的执行路径
    close(1);  // 关闭标准输出文件描述符 (stdout)

    open("output.txt", O_WRONLY | O_CREATE);  
    // 打开或创建 output.txt，并返回文件描述符1（覆盖之前的标准输出）

    char *argv[] = { "echo", "this", "is", "redirected", "echo", 0 };
    exec("echo", argv);  // 使用 echo 替换当前子进程，输出会重定向到 output.txt

    printf("exec failed!\n"); // 如果 exec 失败才会执行这一行
    exit(1);  // 子进程退出
} else {
    wait((int *) 0);  // 父进程等待子进程执行完成
}

exit(0);  // 父进程退出
```

------

#### **逐步讲解：**

##### 1. **`fork()`** - 创建子进程

- `fork()`会将当前进程（父进程）复制一份作为**子进程**。
- 如果`fork()`的返回值为`0`，意味着这是在**子进程**内执行的代码。
- 父进程会继续执行`else`中的部分，并等待子进程完成。

##### 2. **关闭文件描述符1**

- ==在子进程内，我们执行 `close(1)`，即关闭**标准输出**（stdout），它的文件描述符编号为`1`。==
- 关闭后，文件描述符1会被**释放**。

##### 3. **打开或创建文件**

- ==**`open()`**打开文件`output.txt`，并且由于`close(1)`释放了1号文件描述符，系统会自动将文件描述符1分配给`output.txt`。==
- 现在，**标准输出**已经重定向到`output.txt`。

##### 4. **执行`exec()`**

- 调用`exec()`用`echo`命令替换子进程的可执行文件。
- 由于标准输出已经重定向到`output.txt`，`echo`命令的输出会写入该文件，而不会显示在终端上。

##### 5. **等待子进程**

- 父进程在`wait()`处等待子进程完成，然后打印退出状态。

------

#### **为什么重定向有效？**

- **子进程的标准输出**被重定向到`output.txt`，所以即使运行了`echo`，它的输出也不会显示在终端上。
- 打开文件时，返回的文件描述符是`1`，覆盖了原来的**标准输出**。这样，`echo`的输出就会写入`output.txt`。

------

#### **运行结果：**

- 终端上没有任何输出（因为子进程的输出被重定向了）。
- 文件`output.txt`的内容如下：

```
this is redirected echo
```

------

#### **总结：**

- 本代码展示了如何通过`fork()`和`exec()`实现I/O重定向的机制。
- 关键在于**fork和exec之间的间隔**，这个间隔允许子进程在`exec()`前改变文件描述符，将输出重定向到一个文件。
- `echo`命令完全不需要知道发生了重定向，它只负责写入文件描述符1，文件描述符1已经与`output.txt`关联。

你可以根据这个分析进一步实验，理解**fork-exec模型**与**I/O重定向**的应用。

------

### **详细总结：fork 和 exec 的 I/O 重定向机制**

**背景：**

在上面的描述中，代码示例演示了如何通过 **fork** 和 **exec** 实现 **I/O重定向**。这种操作非常典型，在 **Unix Shell** 中，我们经常使用这种模式。例如：

```
echo "hello" > output.txt
```

这里的 **Shell** 通过重定向，将 **`echo` 命令的输出**保存到了 `output.txt` 文件中，而不是在终端打印。这种机制的本质就是使用 **fork + exec** 配合**重定向文件描述符**。

------

#### **文字描述的核心要点：**

1. Shell 中的 I/O 重定向机制：

   - 在 Shell 中，当我们使用重定向符号 >，例如：

     ```
     echo "hello" > out.txt
     ```

     echo的输出不再显示在终端上，而是保存到文件 out.txt中。

   - ==**Shell** 的做法是：**先创建一个子进程（fork）**，在子进程中 **修改文件描述符**，将输出文件描述符重定向到文件。然后运行你输入的指令，比如 `echo`，将其输出写入文件。==

------

#### **描述中的关键步骤与解释：**

1. fork 和 exec 的分离使用：

   - **fork()**：复制当前进程，创建一个 **子进程**。子进程几乎与父进程一模一样（内存和文件描述符都相同）。
   - **exec()**：执行一个新的程序，替换掉子进程的地址空间和指令。

   > **描述的重点**：Unix 程序的常见用法是**fork** 一个子进程，然后在子进程中调用 **exec** 来执行目标命令。这是为了避免主进程被替换为新命令。通过这种方式，主进程可以保留并等待子进程完成工作。

------

1. 为什么分离 fork 和 exec 是必要的：
   - fork 和 exec 是分开的系统调用。这意味着：
     - **fork() 之后，子进程可以先做一些准备工作**（比如修改文件描述符），然后再通过 **exec()** 来运行新的程序。
     - ==如果直接用 **exec** 替换了当前进程（而不 fork），当前进程的所有状态都会被新的程序替代。这对于 **Shell** 来说是不希望发生的，因为我们希望 Shell 保持运行，不会因为执行了某个命令而消失。==

------

1. 在子进程中重定向文件描述符：
   - 描述提到：**第15行的 `close(1)` 关闭了文件描述符1**，也就是 **stdout**（标准输出）。
   - 接着使用 **open()** 打开或创建 `output.txt` 文件。因为文件描述符1被释放了，**open()** 将返回文件描述符1，这样就实现了将**标准输出重定向到文件**的效果。

------

1. echo 不知道输出发生了重定向：
   - 在描述中提到：`echo` 命令并**不知道文件描述符的改变**，它只是将输出写入**文件描述符1**。
   - 由于 **文件描述符1** 已经与 `output.txt` 关联，因此 `echo` 的输出最终被写入文件，而不是终端。

------

1. exec 替换进程并执行命令：
   - 在子进程中调用 **exec** 替换掉当前进程，并执行 `echo` 命令。
   - 因为 **文件描述符1** 已经被重定向到 `output.txt`，所以 **echo** 的输出会写入该文件。

------

1. fork 和 exec 之间的间隔的意义：
   - 描述中特别强调了：在 **fork** 和 **exec** 之间存在一段时间。在这段时间内，子进程依然运行着父进程的代码。
   - 这使得子进程可以在调用 **exec** 之前做一些调整（比如重定向文件描述符），而这些调整不会影响到父进程。

------

1. 父进程的角色：
   - 描述中提到：父进程执行 **wait()** 等待子进程完成。
   - 父进程继续正常运行，没有受到子进程中 **I/O 重定向** 的影响。

#### **描述中的核心思想：I/O 重定向的实现原理**

1. **fork 创建子进程**：
   - 确保 Shell 或父进程不会受到新进程的输出影响。
2. **在子进程中关闭标准输出**：
   - 释放文件描述符1（标准输出）。
3. **将文件描述符1与文件关联**：
   - 通过 **open()** 打开文件 `output.txt`，并将其分配给文件描述符1。
4. **使用 exec 替换子进程**：
   - 执行新的程序（echo），该程序将输出写入重定向后的文件描述符1。
5. **父进程等待子进程完成**：
   - 使用 **wait()** 保持同步。

#### **总结：描述中的关键点**

- **I/O 重定向** 的实现依赖于 **fork** 和 **exec** 之间的间隔，这段时间可以让子进程完成重定向操作。
- 子进程重定向文件描述符不会影响父进程，因此 **父进程** 和 **子进程** 的 I/O 是隔离的。
- **open()** 的行为是返回当前可用的最小文件描述符，因此关闭文件描述符1后，`open()` 会将 **output.txt** 分配给1号描述符（标准输出）。
- `exec()` 完全替换子进程的程序，而 **echo** 作为新程序执行时，只会按照文件描述符的现状进行输出，不需要知道重定向发生了什么。

这个描述强调了 **Unix 系统调用的灵活性**，以及 **fork + exec** 模式的强大之处。这种模式使得 Shell 等系统可以在执行命令之前灵活调整子进程的环境，而不影响自身的运行状态。

------

在你提供的代码中：

```
exec("echo", argv);  // 使用 echo 替换当前子进程，输出会重定向到 output.txt

printf("exec failed!\n"); // 如果 exec 失败才会执行这一行
exit(1);  // 子进程退出
```

**回答：这两行代码通常不会执行。**

**原因：**

1. **exec** 系列函数（如 `exec()`）会完全**替换当前进程的地址空间**，即当前进程的代码和数据会被新的可执行程序（这里是 `echo` 命令）替换。
2. **如果 exec 成功**，当前进程被新程序（`echo`）替代，所有原始进程中的代码，包括 `printf()` 和 `exit()`，**都不会再执行**。
3. **如果 exec 失败**（比如目标程序不存在或路径错误），exec 函数会返回**-1**，此时才会执行 `printf("exec failed!\n");` 和 `exit(1);`。

------

#### **总结：**

- **正常情况下**：`exec("echo", argv);` 成功后，当前子进程会被 `echo` 替代，因此 `printf()` 和 `exit()` 不会执行。
- **异常情况下**：如果 **`exec()` 调用失败**（例如 `echo` 命令不存在或路径错误），才会执行 `printf("exec failed!\n");`，并通过 `exit(1);` 让子进程退出。

所以，**这两行代码是用来处理 exec() 出错的情况的。** 但如果一切正常，它们不会被执行。



------

对于这里的redirect例子，有什么问题吗？

（沉默了一会）

好吧，我们时间快到了，我来总结一下。我们这节课：

* 看了一些Unix I/O和进程的接口和抽象。这里需要记住的是，接口是相对的简单，你只需要传入表示文件描述符的整数，和进程ID作为参数给相应的系统调用。而接口内部的实现逻辑相对来说是复杂的，比如创建一个新的进程，拷贝当前进程。
* 除此之外，我还展示了一些例子。通过这些例子你可以看到，尽管接口本身是简单的，但是可以将多个接口结合起来形成复杂的用例。比如说创建I/O重定向。

在下周结束之前，需要完成一个实验，这个实验中涉及更多类似于我们课堂上讲的简单小工具。好好做实验，我们下周再见。
