# 1.9 exec, wait系统调用

在接下来我展示的一个例子中，会使用echo，echo是一个非常简单的命令，它接收任何你传递给它的输入，并将输入写到输出。

![](<../.gitbook/assets/image (305).png>)

我为你们准备了一个文件名为exec的代码，

```
cat -n exec.c #-n set number
```

![](<../.gitbook/assets/image (249).png>)

==**代码会执行exec系统调用，这个系统调用会从指定的文件中读取并加载指令，并替代当前调用进程的指令。从某种程度上来说，这样相当于丢弃了调用进程的内存，并开始执行新加载的指令。**==

所以第12行的系统调用exec会有这样的效果：==**操作系统从名为echo的文件中加载指令到当前的进程中(即执行exec命令，在Linux系统中都是一切皆文件)**，并替换了当前进程的内存，之后开始执行这些新加载的指令。同时，你可以传入命令行参数，exec允许你传入一个命令行参数的数组==，这里就是一个C语言中的指针数组，在上面代码的第10行设置好了一个**字符指针的数组**，这里的字符指针本质就是一个字符串（string）。

所以这里等价于运行echo命令，并带上“this is echo” 这三个参数。所以当我运行exec文件，

![](<../.gitbook/assets/image (282).png>)

我可以看到“this is echo”的输出。即使我运行了exec程序，exec程序实际上会调用exec系统调用，并用echo指令来代替自己，所以这里是echo命令在产生输出。

------

### 补充：

这段代码展示了使用 `exec` 系统调用来替换当前进程的可执行文件。下面是代码的逐步解释：

### **代码解析：**

```
// exec.c: replace a process with an executable file
```

这是一段示例代码，用于演示如何使用 `exec` 函数将当前进程替换为一个新的可执行程序。

```
#include "kernel/types.h"
#include "user/user.h"
```

这两行是头文件的引入：

- **`kernel/types.h`**：可能定义了一些基础类型（如 `int`、`char`）。
- **`user/user.h`**：包含用户空间函数（如 `exec` 和 `printf`）的声明。

------

### **main 函数：**

```
int main()
{
    char *argv[] = { "echo", "this", "is", "echo", 0 };
```

1. 定义了一个 char* 数组 argv

   其中：
   
   - **`echo`** 是要执行的程序名（通常在 shell 中用于打印参数到标准输出）。
   - **`this`**、**`is`**、**`echo`** 是传递给 `echo` 程序的参数。
   - 数组的最后一个元素是 **`0`**（或 NULL），表示数组结束。

------

```
    exec("echo", argv);
```

1. 调用了 `exec` 函数，这会将当前进程替换为 echo命令，并传递参数 argv

   - 如果执行成功，当前进程会变成 `echo` 命令，后续的代码将不会运行。
- 如果执行失败（例如找不到 `echo`），控制会返回到这行代码后面。

------

```
    printf("exec failed!\n");
```

1. 如果 `exec` 执行失败，则打印 `"exec failed!"` 以提示用户。

------

```
    exit(0);
}
```

1. 调用 **`exit(0)`** 结束程序，返回状态码 `0`，表示正常退出。

------

### **代码运行逻辑：**

1. 当程序运行时，`exec` 尝试用 `echo` 命令替换当前进程。

2. 如果 echo执行成功，当前进程就会被 echo替换，程序的输出将是：

   ```
   this is echo
   ```

3. 如果 exec失败，程序会打印：

   ```
   exec failed!
   ```

### **总结：**

这段代码展示了 **`exec`** 系统调用的使用，它用于将当前进程替换为一个新的可执行文件。`exec` 成功时不会返回，如果失败了，程序会继续执行后面的代码并打印错误信息。这种用法在操作系统中非常常见，例如 shell 在执行命令时就会使用 `exec` 系列函数。

------

### 补充：什么叫这会将当前进程替换为 echo 命令，并传递参数 argv，但是argv不还有一个echo字符吗，那不就会有2个echo

很好！你的问题非常细致。确实，在代码中 `argv` 数组的第一个元素和 `exec` 函数的第一个参数都传递了 `"echo"`，看起来好像有两个 `"echo"`。让我们仔细理解 **`exec`** 的工作原理，尤其是为什么需要这么做。

### **==exec 的本质==**

==`exec` 系列函数（例如 `execv`、`execl` 等）会用指定的可执行文件（如 `/bin/echo`）**替换当前进程的映像**，使这个进程成为目标程序（在这里是 `echo` 命令）。但是，这些目标程序通常会依赖它们的 **命令行参数** 来决定自己的行为。==

### **argv 的第一个元素的作用**

当你在 shell 中运行一个命令时，类似于：

```
echo this is echo
```

这里，`echo` 其实不仅是命令名，还会作为程序运行时的 **第一个参数**。系统会通过这个参数告诉程序它的名字或路径是什么。

所以，在 `exec` 系统调用中，**`argv[0]`** 约定俗成地表示你执行的**命令本身的名称**。虽然你可以随意改这个名字，但按照惯例，它通常就是程序名。例如：

- 你可以运行：

  ```
  /bin/echo this is echo
  ```

  这时，

  ```
  /bin/echo
  ```

   命令会把第一个参数 

  ```
  argv[0]
  ```

   设为 

  ```
  "echo"
  ```

即便你运行：

```
/bin/echo foo
```

`echo` 仍然会认为自己叫 `"echo"`，因为 `argv[0]` 是 `"echo"`。

### **代码中的双重 echo：**

在你的代码中：

```
char *argv[] = { "echo", "this", "is", "echo", 0 };
exec("echo", argv);
```

- ==**`exec` 的第一个参数** `"echo"` 告诉内核：我们要用 `echo` 程序（通常在 `/bin/echo`）替换当前进程。==
- **`argv[0] = "echo"`** 是作为惯例，表示这个新进程自己的名称。

所以当 `exec` 替换成功后，这个进程就相当于执行：

```
echo this is echo
```

输出结果是：

```
this is echo
```

### **argv[0] 可以修改吗？**

是的，你完全可以修改它。例如：

```
char *argv[] = { "my_echo", "this", "is", "echo", 0 };
exec("echo", argv);
```

这段代码会把 `argv[0]` 设置为 `"my_echo"`，但它并不会改变程序的行为，只是 `echo` 程序会认为自己叫 `"my_echo"`。

### **总结：**

1. **`argv[0]`** 代表的是新进程的名称或路径，这是一种惯例，供程序运行时识别自己。
2. 在你的例子中，两个 `"echo"` 一个用于指定要执行的命令路径，一个作为参数传递给新进程。
3. **你可以改动 `argv[0]`**，但程序的功能不会因此改变。

这个设计的主要目的是方便程序通过 `argv[0]` 判断自己是如何被调用的。例如，一些命令可能根据 **`argv[0]` 的内容**来决定它的行为。

------

有关exec系统调用，有一些重要的事情，

1. ==exec系统调用会保留当前的文件描述符表单。所以任何在exec系统调用之前的文件描述符，例如0，1，2等。它们在新的程序中表示相同的东西。==
2. ==通常来说exec系统调用不会返回，==因为exec会完全替换当前进程的内存，相当于当前进程不复存在了，所以exec系统调用已经没有地方能返回了。

所以，exec系统调用从文件中读取指令，执行这些指令，然后就没有然后了。exec系统调用只会当出错时才会返回，因为某些错误会阻止操作系统为你运行文件中的指令，例如程序文件根本不存在，因为exec系统调用不能找到文件，exec会返回-1来表示：出错了，我找不到文件。所以通常来说exec系统调用不会返回，它只会在kernel不能运行相应的文件时返回。

有关exec有什么问题吗？

> 学生提问：argv中的最后一个0是什么意思？
>
> Robert教授：它标记了数组的结尾。C是一个非常低阶（接近机器语言）的编程语言，并没有一个方法来确定一个数组究竟有多长。所以为了告诉内核数组的结尾在哪，==我们将0作为最后一个指针。==argv中的每一个字符串实际上是一块包含了数据的内存指针，但是第5个元素是0，==通常来说指针0是一个NULL指针，它只表明结束。所以内核中的代码会遍历这里的数组，直到它找到了值为0的指针。==

### 实际是先调用fork,再调用exec

好的，这就是一个程序如何用文件中的另一个程序来替代自己。==实际上，当我们在Shell中运行类似于“echo a b c”的指令，或者ls，或者任何命令，我们不会想要代替Shell进程，所以我们不会希望Shell执行exec系统调用。==如**果我们这么做了，这里会用echo指令来替代Shell进程，当echo退出了，一切就结束了。所以我们不想要echo替代Shell。**==实际上，Shell会执行fork，之后fork出的子进程再调用exec系统调用，这是一个非常常见的Unix程序调用风格。==对于那些想要运行程序，但是还希望能拿回控制权的场景，可以先执行fork系统调用，然后在子进程中调用exec。

这里有一个简单的例子，来演示fork/exec程序。

![](<../.gitbook/assets/image (338).png>)

==在这个程序中的第12行，调用了fork。子进程从第14行开始，我们在子进程中与前一个程序一样调用exec。子进程会用echo命令来代替自己，echo执行完成之后就退出。之后父进程重新获得了控制。fork会在父进程中返回大于0的值，父进程会继续在第19行执行。==



==**Unix提供了一个wait系统调用，如第20行所示。wait会等待之前创建的子进程退出。当我在命令行执行一个指令时，我们一般会希望Shell等待指令执行完成。**==

==**所以wait系统调用，使得父进程可以等待任何一个子进程返回。这里wait的参数status，是一种让退出的子进程以一个整数（32bit的数据）的格式与等待的父进程通信方式。**==

==所以在第17行，exit的参数是1，操作系统会将1从退出的子进程传递到第20行，也就是等待的父进程处。&status，是将status对应的地址传递给内核，内核会向这个地址写入子进程向exit传入的参数。==

Unix中的风格是，**如果一个程序成功的退出了，那么exit的参数会是0，如果出现了错误，那么就会像第17行一样，会向exit传递1。**所以，如果你关心子进程的状态的话，父进程可以读取wait的参数，并决定子进程是否成功的完成了。

------

### 补充：这段代码演示了 **fork/exec** 模式的使用，这是 UNIX 系统中运行新程序的常见方式。

下面我会详细解释代码中的每个部分，以及 `fork` 和 `exec` 系统调用是如何协同工作的。

------

#### **代码详细解释**

```C
#include "user/user.h"

// forkexec.c: fork then exec

int main() {
    int pid, status;

    pid = fork(); // 第一次调用 fork 系统调用
    if (pid == 0) {  // 如果是子进程
        char *argv[] = { "echo", "THIS", "IS", "ECHO", 0 };
        exec("echo", argv); // 在子进程中执行 echo 命令
        printf("exec failed!\n"); // 如果 exec 失败，打印错误信息
        exit(1); // 退出子进程，返回状态码 1
    } else {  // 如果是父进程
        printf("parent waiting\n"); // 父进程等待子进程结束
        wait(&status); // 使用 wait 等待子进程结束，并获取状态
        printf("the child exited with status %d\n", status); // 打印子进程的退出状态
    }

    exit(0); // 父进程正常退出
}
```

------

#### **核心概念：fork 和 exec**

1. **`fork()`**：
   - `fork()` 系统调用会创建一个**子进程**，这个子进程是父进程的副本。
   - 父进程和子进程会从 `fork` 之后的代码开始并行运行，但 fork的返回值会告诉我们当前处于哪个进程中：
     - 在 **父进程** 中，`fork()` 返回子进程的 PID（> 0）。
     - 在 **子进程** 中，`fork()` 返回 0。
2. **`exec()`**：
   - `exec()` 会将当前进程的映像**替换为新的可执行文件**，在这里是 `echo` 命令。
   - 如果 `exec()` 成功，当前进程会被替换成 `echo` 程序，之后代码不会再执行 `printf()` 和 `exit()`。
   - 如果 `exec()` 失败，程序会打印 `"exec failed!"` 并退出。

------

#### **运行过程分析**

##### **步骤 1：fork 创建子进程**

```
pid = fork();
```

- ==fork会创建一个子进程。父进程和子进程都会**从这行代码后开始执行**。pid的值区分了两者：==
  - 在 **子进程** 中：`pid == 0`
  - 在 **父进程** 中：`pid > 0`（这是子进程的 PID）

##### **步骤 2：子进程执行 exec**

```C
if (pid == 0) {
    char *argv[] = { "echo", "THIS", "IS", "ECHO", 0 };
    exec("echo", argv);
    printf("exec failed!\n");
    exit(1);
}
```

- 如果是子进程，它会创建一个 argv数组，并调用 exec()

   来运行 echo命令。

  - **`argv` 数组**：`argv[0]` 是程序名 `"echo"`，后面的元素是命令行参数 `"THIS" "IS" "ECHO"`。
  - **`exec()` 成功**：当前进程会被 `echo` 替换，`printf()` 和 `exit()` 不会执行。
  - **`exec()` 失败**：会打印 `"exec failed!"`，然后退出子进程并返回状态码 1。

##### **步骤 3：父进程等待子进程结束**

```C
else {
    printf("parent waiting\n");
    wait(&status);
    printf("the child exited with status %d\n", status);
}
```

- 如果是 **父进程**，它会打印 `"parent waiting"`，然后调用 `wait()` 来等待子进程结束。
- **`wait()`**：暂停父进程的执行，直到子进程结束。子进程的退出状态会存储在 `status` 中。
- 当子进程退出后，父进程会打印子进程的退出状态。

------

#### **示例运行结果**

- **子进程**会运行：

  ```sh
  echo THIS IS ECHO
  ```

  输出结果是：

  ```sh
  THIS IS ECHO
  ```

- **父进程**会等待子进程结束，并输出类似下面的内容：

  ```sh
  parent waiting
  the child exited with status 0
  ```

#### **总结**

1. **`fork/exec` 是 UNIX 中非常常见的模式**：
   - **`fork`** 用于创建子进程。
   - **`exec`** 用于让子进程运行新的程序。
2. **`wait` 保证了父进程在子进程结束后继续执行**。
3. **子进程退出状态**会通过 `wait()` 返回给父进程。这里状态为 0，表示正常退出。

#### **为什么不用直接调用 exec？**

- ==如果我们在主程序中直接调用 `exec()` 而不是 `fork()`，那么当前进程（父进程）会被替换成 `echo` 程序，Shell 进程也会被替换，导致控制台退出。==
- 使用 `fork/exec` 模式，我们可以确保：
  - ==子进程负责运行新程序。==
  - ==父进程可以继续执行，并等待子进程结束。==

这就是为什么在 Shell 中运行命令时，Shell 会先 `fork()`，再让子进程 `exec()` 命令，从而保证 Shell 进程不会被替换。

------





> ==学生提问：有关第15行的exec系统调用，在刚刚提到exec会完全走到echo程序，而不会返回到fork出的子进程中，所以代码有可能走到底16，17行吗？==
>
> Robert教授：对于上面例子中的exec，代码不会走到16，17行，因为这里就是调用了echo。但是，如果我修改代码，那就有可能会走到那两行了。首先，我先运行一下原始版本的程序

![](<../.gitbook/assets/image (308).png>)

> 可以看出，==程序执行了echo，并传入了相应的参数。同时子进程以状态0退出，表明echo成功的退出了，并且父进程在等待子进程。==
>
> **接下来，我修改一下代码。这次我将会运行一个不存在的指令，**

![](<../.gitbook/assets/image (214).png>)

> ==为了让修改生效，我需要退出QEMU，并重建所有的东西以使得我的修改能够被编译。==之后我再运行forkexec，

![](<../.gitbook/assets/image (316).png>)

> 这一次，==因为我们想要执行的指令并不存在，exec系统调用会返回==，我们可以看到“exec failed!”的输出，同时exit(1)的参数1，传递给了父进程，父进程会打印出子进程的退出码。所以，exec系统调用只会在出错的时候返回给调用进程。

### fork/exec带来的浪费

这里有一些东西需要注意，实际上我认为你们很多人已经注意到了，这里是一个常用的写法，先调用fork，再在子进程中调用exec。==这里实际上有些浪费，fork首先拷贝了整个父进程的，但是之后exec整个将这个拷贝丢弃了，并用你要运行的文件替换了内存的内容。某种程度上来说这里的拷贝操作浪费了，因为所有拷贝的内存都被丢弃并被exec替换。==在大型程序中这里的影响会比较明显。如果你运行了一个几G的程序，并且调用fork，那么实际就会拷贝所有的内存，可能会要消耗将近1秒钟来完成拷贝，这可能会是个问题。

在这门课程的后面，你们会实现一些优化，比如说copy-on-write fork，这种方式会消除fork的几乎所有的明显的低效，而只拷贝执行exec所需要的内存，这里需要很多涉及到虚拟内存系统的技巧。你可以构建一个fork，对于内存实行lazy拷贝，通常来说fork之后立刻是exec，这样你就不用实际的拷贝，因为子进程实际上并没有使用大部分的内存。我认为你们会觉得这将是一个有趣的实验。

### 补充：你提出的问题很有价值——经典的 **`fork()` + `exec()`** 模式的确存在潜在的性能问题，尤其是在**大型程序**的场景下。

这个问题的根源在于：`fork()` 会**复制整个父进程的内存空间**，但紧接着 `exec()` 调用会**直接替换整个子进程的内存**。这个过程使得复制的大部分内存变得没有用，造成了浪费。

#### **问题：fork 后紧接着 exec 的低效**

- **`fork()`**：它会复制整个父进程的内存（尽管是虚拟内存）。
- **`exec()`**：直接丢弃 `fork` 创建的副本，将子进程的内存替换成新的可执行程序。

对于小程序，这个开销可能不明显。但如果你有一个占用了**几 GB 内存**的程序，例如某个数据处理服务，`fork()` 会花费大量时间去复制这些数据。而最终这些数据会在 `exec()` 调用时被替换，浪费了 CPU 和内存资源。

#### **解决方案：Copy-on-Write (COW)**

Copy-on-Write (COW) 是一种优化技术，它减少了 `fork()` 和 `exec()` 的浪费。其核心思想是：**在真正需要修改时才实际复制内存**。在此之前，父进程和子进程共享同一块物理内存。

- 如何工作：
  1. 当 `fork()` 创建子进程时，不会立即复制整个内存空间，而是让父进程和子进程共享同一块物理内存。
  2. 共享的内存页被标记为**只读**。如果父进程或子进程尝试写入这块内存时，操作系统会捕捉到**缺页异常**。
  3. 发生缺页异常时，系统会**复制**尝试修改的内存页，并让进程各自拥有该页的独立副本（**这就是“写时复制”**）。
  4. 如果子进程立刻调用 `exec()`，则不会有任何实际的复制发生，因为子进程没有修改共享内存。

#### **举例：使用 Copy-on-Write 的 fork()**

假设我们有一个父进程占用了 4 GB 内存，并执行以下代码：

```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    // 分配 4GB 的内存
    size_t size = 4L * 1024 * 1024 * 1024; // 4GB
    char *large_array = malloc(size);

    if (large_array == NULL) {
        perror("malloc failed");
        exit(1);
    }

    // 初始化数组中的一部分
    for (size_t i = 0; i < 1024; ++i) {
        large_array[i] = 'A';
    }

    printf("Parent process: allocated 4GB\n");

    // 调用 fork()
    pid_t pid = fork();
    if (pid < 0) {
        perror("fork failed");
        exit(1);
    } else if (pid == 0) {
        // 子进程调用 exec 替换自身
        printf("Child process: calling exec\n");
        char *argv[] = { "echo", "Hello from child!", NULL };
        execvp("echo", argv);
        perror("exec failed");
        exit(1);
    } else {
        // 父进程等待子进程
        wait(NULL);
        printf("Parent process: child exited\n");
    }

    free(large_array);
    return 0;
}
```

#### **解释运行过程**

1. **父进程运行并分配了 4GB 的内存**：
   - 父进程初始化了这块内存的一部分，证明它成功占用了 4GB 虚拟地址空间。
2. **`fork()` 执行**：
   - 由于使用了 **Copy-on-Write**，子进程最初与父进程**共享这 4GB 的物理内存**，没有实际复制。
3. **子进程调用 `exec()`**：
   - 由于 `exec()` 会替换整个进程的地址空间，之前共享的内存**直接被释放**，也不需要真正复制。
4. **父进程等待子进程结束**：
   - 父进程调用 `wait()`，等待子进程打印 `"Hello from child!"` 后退出。

#### **Copy-on-Write 的优势**

- **节省内存**：只有在写入时才会真正复制内存页，大大减少了内存使用。
- **提高性能**：如果 `fork()` 后立即调用 `exec()`，几乎不需要实际复制内存页，提升了速度。
- **适用场景**：适用于大多数 `fork` 后立即 `exec` 的情况，特别是**大型进程**。

#### **总结**

使用 **Copy-on-Write** 解决了 `fork()` + `exec()` 模式中的低效问题：

- 父子进程共享内存，只有在需要写入时才复制。
- 如果子进程在 `fork()` 后立即调用 `exec()`，则不会发生任何内存复制操作。

这种优化对于运行**大型进程**的场景非常重要，确保系统不会因为不必要的内存复制而浪费资源。

------

### 补充：上述代码哪里使用Copy-on-Write了，没看出来

你说得对，我的代码示例展示了一个普通的 `fork()` + `exec()` 过程，但我并没有明确展示如何在代码中控制或直接使用 **Copy-on-Write (COW)**。实际上，**Copy-on-Write** 是由操作系统的虚拟内存管理系统自动实现的，开发者不需要在代码中显式启用它。

接下来，我会详细解释 **Copy-on-Write** 是如何在这个例子中隐含地被操作系统使用的。

### **Copy-on-Write (COW) 是操作系统层面实现的**

在 **Linux** 以及大多数 **Unix 系统**中，`fork()` 在创建子进程时，不会马上复制父进程的整个内存，而是将父子进程的**内存页标记为只读**，并使用 **共享页面的方式**。只有当父进程或子进程**尝试写入**这些页面时，操作系统才会通过缺页异常(**page fault**)复制相关页面。

### **在示例代码中，COW 是如何发挥作用的？**

让我们详细分析上面代码中的 **`fork()`** 部分。

```C
pid_t pid = fork();
if (pid < 0) {
    perror("fork failed");
    exit(1);
} else if (pid == 0) {
    // 子进程调用 exec 替换自己
    char *argv[] = { "echo", "Hello from child!", NULL };
    execvp("echo", argv);
    perror("exec failed");
    exit(1);
} else {
    // 父进程等待子进程
    wait(NULL);
    printf("Parent process: child exited\n");
}
```

1. **执行 `fork()`**：
   - 当 `fork()` 被调用时，操作系统会创建一个**子进程**，并让它**共享父进程的虚拟地址空间**（即，父子进程的内存页最初是共享的）。
   - **共享的页面是只读的**。这意味着，如果父进程或子进程**只读这些页面**，那么不会有任何实际的内存复制发生。
2. **什么时候会触发 COW？**：
   - 如果 **子进程在执行 `exec()`** 之前尝试修改任何共享页面，系统会捕捉到**缺页异常**（Page Fault），并**复制那一页内存**给子进程。这就是 COW 的工作原理。
3. **为什么我们的例子没有真正触发 COW？**：
   - 在我们的代码中，**子进程在调用 `exec()` 之前没有对内存进行任何写入操作**。因此，操作系统无需复制任何页面——共享的内存直接被替换为新的可执行文件的内容。

### **如何理解代码中的 COW 优化**

在这个例子中，**COW 并没有被真正触发**，因为：

- 子进程在调用 `fork()` 后，立刻执行了 `exec()`，这会**替换整个进程的内存空间**。
- 由于没有修改共享内存页的行为，操作系统**避免了不必要的内存复制**。

这正是 **COW 的优势**：在很多常见的 **`fork()` + `exec()`** 场景中，不需要实际复制内存，从而大大节省了时间和资源。

### **如何触发 COW？（代码示例）**

如果你希望看到 COW 机制的实际触发情况，可以尝试让子进程在 `exec()` 之前**修改内存**：

```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    // 分配 1 MB 的内存
    size_t size = 1L * 1024 * 1024; // 1MB
    char *large_array = malloc(size);

    if (large_array == NULL) {
        perror("malloc failed");
        exit(1);
    }

    // 初始化数组中的一部分
    for (size_t i = 0; i < 1024; ++i) {
        large_array[i] = 'A';
    }

    printf("Parent process: initialized 1MB memory\n");

    pid_t pid = fork();
    if (pid < 0) {
        perror("fork failed");
        exit(1);
    } else if (pid == 0) {
        // 子进程尝试修改共享的内存，触发 COW
        large_array[0] = 'B';
        printf("Child process: modified shared memory\n");

        // 调用 exec 替换子进程（不会到达这一步）
        char *argv[] = { "echo", "Hello from child!", NULL };
        execvp("echo", argv);
        perror("exec failed");
        exit(1);
    } else {
        // 父进程等待子进程
        wait(NULL);
        printf("Parent process: child exited\n");
    }

    free(large_array);
    return 0;
}
```

#### **示例解释**

1. 父进程分配了 **1 MB 内存**，并初始化部分内容。
2. 调用 `fork()` 后，父子进程**共享内存**。
3. **子进程修改了共享内存**（`large_array[0] = 'B';`）。
4. 由于共享内存是**只读共享**，修改会**触发 COW**，操作系统会复制这一页给子进程。
5. 子进程尝试调用 `exec()` 替换自身（虽然在此例中不会执行成功，因为我们只展示了 COW 的触发）。

### **总结**

在正常的 **`fork()` + `exec()`** 场景中，**Copy-on-Write** 允许父子进程共享内存，减少了不必要的内存复制。如果子进程没有在 `exec()` 之前写入共享内存，那么不会触发 COW，也不会浪费时间和资源。

COW 的真正价值在于：

- 避免了大规模的内存复制。
- 在子进程修改共享内存时，才会进行**按需复制**，最大化性能和内存利用率。

你的初始代码示例中并没有显示 COW 的实际触发过程，因为子进程没有修改任何内存。然而，操作系统的 COW 机制依然在幕后起到了作用，避免了不必要的内存复制。

------



> 学生提问：为什么父进程在子进程调用exec之前就打印了“parent waiting”？
>
> Robert教授：这里只是巧合。父进程的输出有可能与子进程的输出交织在一起，就像我们之前在fork的例子中看到的一样，只是这里正好没有发生而已。并不是说我们一定能看到上面的输出，实际上，如果看到其他的输出也不用奇怪。我怀疑这里背后的原因是，exec系统调用代价比较高，它需要访问文件系统，访问磁盘，分配内存，并读取磁盘中echo文件的内容到分配的内存中，分配内存又可能需要等待内存释放。所以，exec系统调用背后会有很多逻辑，很明显，处理这些逻辑的时间足够长，这样父进程可以在exec开始执行echo指令之前完成输出。这样说得通吧？
>
> 学生提问：子进程可以等待父进程吗？
>
> Robert教授：Unix并没有一个直接的方法让子进程等待父进程。wait系统调用只能等待当前进程的子进程。所以wait的工作原理是，如果当前进程有任何子进程，并且其中一个已经退出了，那么wait会返回。但是如果当前进程没有任何子进程，比如在这个简单的例子中，如果子进程调用了wait，因为子进程自己没有子进程了，所以wait会立即返回-1，表明出现错误了，当前的进程并没有任何子进程。
>
> 简单来说，不可能让子进程等待父进程退出。
>
> 学生提问：当我们说子进程从父进程拷贝了所有的内存，这里具体指的是什么呢？是不是说子进程需要重新定义变量之类的？
>
> Robert教授：在编译之后，你的C程序就是一些在内存中的指令，这些指令存在于内存中。所以这些指令可以被拷贝，因为它们就是内存中的字节，它们可以被拷贝到别处。通过一些有关虚拟内存的技巧，可以使得子进程的内存与父进程的内存一样，这里实际就是将父进程的内存镜像拷贝给子进程，并在子进程中执行。
>
> 实际上，当我们在看C程序时，你应该认为它们就是一些机器指令，这些机器指令就是内存中的数据，所以可以被拷贝。
>
> 学生提问：如果父进程有多个子进程，wait是不是会在第一个子进程完成时就退出？这样的话，还有一些与父进程交错运行的子进程，是不是需要有多个wait来确保所有的子进程都完成？
>
> Robert教授：是的，如果一个进程调用fork两次，如果它想要等两个子进程都退出，它需要调用wait两次。每个wait会在一个子进程退出时立即返回。当wait返回时，你实际上没有必要知道哪个子进程退出了，但是wait返回了子进程的进程号，所以在wait返回之后，你就可以知道是哪个子进程退出了。
