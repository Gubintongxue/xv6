# 9.5 UART驱动的top部分

接下来我想看一下如何从Shell程序输出提示符“$ ”到Console。首先我们看init.c中的main函数，这是系统启动后运行的第一个进程。

![](<../.gitbook/assets/image (808).png>)

首先这个进程的main函数创建了一个代表Console的设备。这里通过mknod操作创建了console设备。因为这是第一个打开的文件，所以这里的文件描述符0。之后通过dup创建stdout和stderr。这里实际上通过复制文件描述符0，得到了另外两个文件描述符1，2。最终文件描述符0，1，2都用来代表Console。

Shell程序首先打开文件描述符0，1，2。之后Shell向文件描述符2打印提示符“$ ”。

![](<../.gitbook/assets/image (677).png>)

尽管Console背后是UART设备，但是从应用程序来看，它就像是一个普通的文件。Shell程序只是向文件描述符2写了数据，它并不知道文件描述符2对应的是什么。在Unix系统中，设备是由文件表示。我们来看一下这里的fprintf是如何工作的。

在printf.c文件中，代码只是调用了write系统调用，在我们的例子中，fd对应的就是文件描述符2，c是字符“$”。

![](<../.gitbook/assets/image (661).png>)

所以由Shell输出的每一个字符都会触发一个write系统调用。之前我们已经看过了write系统调用最终会走到sysfile.c文件的sys\_write函数。

![](<../.gitbook/assets/image (830).png>)

这个函数中首先对参数做了检查，然后又调用了filewrite函数。filewrite函数位于file.c文件中。

![](<../.gitbook/assets/image (729).png>)

在filewrite函数中首先会判断文件描述符的类型。mknod生成的文件描述符属于设备（FD\_DEVICE），而对于设备类型的文件描述符，我们会为这个特定的设备执行设备相应的write函数。因为我们现在的设备是Console，所以我们知道这里会调用console.c中的consolewrite函数。

![](<../.gitbook/assets/image (816).png>)

这里先通过either\_copyin将字符拷入，之后调用uartputc函数。uartputc函数将字符写入给UART设备，所以你可以认为consolewrite是一个UART驱动的top部分。uart.c文件中的uartputc函数会实际的打印字符。

![](<../.gitbook/assets/image (755).png>)

uartputc函数会稍微有趣一些。在UART的内部会有一个buffer用来发送数据，buffer的大小是32个字符。同时还有一个为consumer提供的读指针和为producer提供的写指针，来构建一个环形的buffer（注，或者可以认为是环形队列）。

![](<../.gitbook/assets/image (824).png>)

在我们的例子中，Shell是producer，所以需要调用uartputc函数。在函数中第一件事情是判断环形buffer是否已经满了。如果读写指针相同，那么buffer是空的，如果写指针加1等于读指针，那么buffer满了。当buffer是满的时候，向其写入数据是没有意义的，所以这里会sleep一段时间，将CPU出让给其他进程。当然，对于我们来说，buffer必然不是满的，因为提示符“$”是我们送出的第一个字符。所以代码会走到else，字符会被送到buffer中，更新写指针，之后再调用uartstart函数。

![](<../.gitbook/assets/image (780).png>)

uartstart就是通知设备执行操作。首先是检查当前设备是否空闲，如果空闲的话，我们会从buffer中读出数据，然后将数据写入到THR（Transmission Holding Register）发送寄存器。这里相当于告诉设备，我这里有一个字节需要你来发送。一旦数据送到了设备，系统调用会返回，用户应用程序Shell就可以继续执行。这里从内核返回到用户空间的机制与lec06的trap机制是一样的。

与此同时，UART设备会将数据送出。在某个时间点，我们会收到中断，因为我们之前设置了要处理UART设备中断。接下来我们看一下，当发生中断时，实际会发生什么。



------



# 9.5 UART驱动的Top部分

本节课程中，我们深入剖析了从Shell程序输出提示符“$”到Console的具体过程，重点放在UART驱动的实现细节。通过对相关代码的逐步解析，我们了解了UART与Console之间的数据传输过程及中断处理机制。

## 1. `init.c`中的`main`函数：系统初始化与Console设备创建

==在XV6启动后，`init.c`中的`main`函数是系统执行的第一个进程。==此进程创建了一个代表Console的设备，以支持后续Shell的输入输出操作：

- **创建Console设备**：通过`mknod`操作创建了Console设备，并赋予文件描述符0。这是系统的第一个打开文件描述符。
- **文件描述符复制**：使用`dup`复制文件描述符0以生成描述符1和2（标准输出和标准输入）。最终，文件描述符0、1和2均代表Console。

接下来，Shell程序打开文件描述符0、1、2，并向文件描述符2打印提示符“$”。

## 2. Console作为UART的抽象文件

==从应用程序的角度来看，Console作为UART的抽象，就像是一个普通文件。==Shell程序并不关心文件描述符2指向的是什么设备。接下来的分析展示了“$”字符输出的具体流程：

- **`fprintf`调用**：在`printf.c`文件中，`fprintf`最终会调用`write`系统调用。此调用将字符“$”通过文件描述符2写入系统。

## 3. `write`系统调用处理流程

### 3.1 `sys_write`函数

==在`sysfile.c`文件中，`write`系统调用到达`sys_write`函数：==

- **参数检查**：`sys_write`首先对参数进行有效性检查。
- **调用`filewrite`函数**：若检查通过，则调用`filewrite`函数，该函数位于`file.c`文件中。

### 3.2 `filewrite`函数

在`filewrite`函数中，系统判断文件描述符的类型。`mknod`生成的文件描述符属于设备类型（`FD_DEVICE`），因此系统会调用该设备的相应`write`函数：

- **调用`consolewrite`函数**：在此处，设备为Console，系统调用`console.c`中的`consolewrite`函数。

## 4. `consolewrite`函数：UART驱动的Top部分

==在`consolewrite`函数中，字符首先被拷贝到一个临时位置，随后调用`uartputc`函数将字符写入UART设备：==

- **拷贝字符**：`consolewrite`通过`either_copyin`函数将字符从用户空间拷贝至内核空间。
- **调用`uartputc`函数**：`uartputc`将字符写入UART设备，是UART驱动的Top部分。

## 5. `uartputc`函数：字符写入UART的核心过程

`uartputc`函数位于`uart.c`文件中，负责将字符送入UART的发送buffer中。以下是函数的详细操作流程：

- **判断Buffer状态**：UART内部有一个32字符的环形Buffer，包含一个写指针（Producer）和读指针（Consumer）用于管理数据。判断Buffer是否满的依据是，若写指针加1等于读指针，则Buffer为满。
- **Buffer写入**：==若Buffer非满，Shell会将字符“$”写入Buffer中，并更新写指针。之后调用`uartstart`函数通知UART设备开始传输数据。==

## 6. `uartstart`函数：UART传输与寄存器操作

`uartstart`函数通知设备将Buffer中的数据发送到Console：

- **检查设备空闲状态**：首先判断UART是否空闲，若空闲则从Buffer中读取数据并写入到UART的THR（Transmission Holding Register）发送寄存器。此操作告诉UART设备有一个字节待发送。
- **传输数据**：数据写入THR后，系统返回到用户空间，允许Shell继续执行。这一内核返回机制与第六节的trap机制类似。

## 7. 中断处理：UART发送数据后的中断机制

==UART设备在将数据发送到Console时会触发中断，这一过程确保系统可以在适当的时间点接收和处理来自UART的数据中断。==

接下来将继续研究当UART产生中断时系统的具体响应机制。







## 拓展：

### 问题：write和sys_write有什么区别

`write` 和 `sys_write` 之间的区别主要在于它们所在的层级和使用方式：

1. **`write` 是 C 库函数**：

   - `write` 是标准 C 库（如 `glibc`）提供的一个函数，它封装了系统调用 `sys_write`。
   - 应用程序通常调用 `write` 来将数据写入文件描述符，如文件、标准输出（`stdout`）、标准错误（`stderr`）等。
   - `write` 函数位于用户空间中，属于用户级别的接口。

   ```
   #include <unistd.h>
   
   ssize_t write(int fd, const void *buf, size_t count);
   ```

   当你调用 `write` 函数时，实际执行的操作是进入内核空间调用 `sys_write`。

2. **`sys_write` 是系统调用**：

   - `sys_write` 是操作系统内核提供的一个系统调用，直接在内核空间中执行。
   - 当应用程序调用 `write` 函数时，`write` 会通过系统调用接口进入内核空间，触发 `sys_write` 函数来实际完成数据写入操作。
   - 系统调用是用户程序与内核交互的唯一途径，它们在内核中被实现并受到操作系统的保护。

   在 Linux 内核中，`sys_write` 的定义通常如下（简化表示）：

   ```
   asmlinkage long sys_write(unsigned int fd, const char __user *buf, size_t count);
   ```

   `sys_write` 的实现会处理文件描述符、权限检查、错误处理等，然后将数据写入对应的文件或设备。

#### 简单流程说明

- **用户空间调用**：应用程序调用 `write`。
- **系统调用接口**：`write` 函数封装了系统调用，进入内核。
- **内核空间处理**：内核中的 `sys_write` 函数被调用，执行实际的文件写入操作。
- **返回用户空间**：操作完成后返回到用户空间，`write` 返回写入的数据字节数或错误码。

#### 总结

- `write` 是用户空间的接口，位于标准 C 库中。
- `sys_write` 是内核空间的系统调用，由 `write` 间接调用以完成实际的数据写入。

------

### 问题：内核是不是控制所有硬件？

是的，**内核负责管理和控制计算机的大部分硬件资源**，但并不是直接控制每一个硬件细节。它通过协调硬件驱动程序、抽象硬件功能、管理资源分配来间接控制硬件设备。具体来说，内核的硬件控制作用包括以下几个方面：

#### 1. **硬件抽象和驱动程序**

- ==内核为每种硬件提供一个 **抽象层**，通过 **设备驱动程序** 来控制和管理硬件设备。==
- ==每种硬件设备（如硬盘、网卡、显示器、键盘、鼠标等）都有专门的驱动程序。内核通过调用这些驱动程序的方法来操作硬件，而不直接控制硬件的底层操作。==

#### 2. **硬件资源管理**

- **内存管理**：内核控制内存的分配和回收，确保进程之间的内存隔离，防止进程之间的相互干扰。
- **CPU 调度**：内核管理 CPU 的使用，控制哪些进程可以在某个时间运行，以实现多任务处理。
- **I/O 管理**：内核控制输入输出设备（如硬盘、网络接口）的访问，管理进程对这些资源的请求。
- **文件系统管理**：内核通过文件系统对存储设备的访问提供一个统一的接口，使用户和程序能方便地读写数据。

#### 3. **中断处理和系统调用**

- ==内核通过 **中断** 和 **系统调用** 实现对硬件事件的响应和处理。例如，当网络接口接收到数据包时，会产生一个中断信号，内核会处理这个中断以响应数据的到达。==
- ==用户程序通过 **系统调用** 请求内核执行特定的硬件操作，比如读写文件、分配内存等。这些操作需要内核来协调和控制。==

#### 4. **安全与隔离**

- 内核控制硬件的访问权限，确保只有经过授权的进程或用户才能访问特定硬件资源。比如，某些关键硬件（如内存管理单元）只能被内核访问，用户空间的程序无法直接操作这些硬件。

#### 5. **时钟和定时器管理**

- 内核控制系统时钟和定时器，用于进程调度、计时、延迟操作等，确保系统按时完成任务。

#### 不是直接控制的硬件

- 某些特定设备或复杂的硬件（例如图形处理器 GPU）也会有 **专用的硬件控制器或固件**，在内核的调配下工作。
- 内核并不直接控制硬件的每一个操作，而是通过抽象层和驱动程序来操作硬件，具体的控制细节由硬件厂商编写的驱动程序或固件负责。

#### 总结

内核**通过抽象和驱动程序管理硬件资源**，但不会直接操控所有硬件细节。内核的作用是协调系统资源的分配、响应硬件事件、确保安全和隔离，以便让操作系统的功能得以正常运行。

------

