# 4.4 页表缓存（Translation Lookaside Buffer）

### 原因-三级页表读取三次内存代价有点高

如果我们回想一下page table的结构，你可以发现，当处理器从内存加载或者存储数据时，基本上都要做3次内存查找，第一次在最高级的page directory，第二次在中间级的page directory，最后一次在最低级的page directory。

==所以对于一个虚拟内存地址的寻址，需要读三次内存，这里代价有点高。==所以实际中，==几乎所有的处理器都会对于最近使用过的虚拟地址的翻译结果有缓存。这个缓存被称为：Translation Lookside Buffer（通常翻译成页表缓存）。==你会经常看到它的缩写TLB。基本上来说，这就是Page Table Entry的缓存，也就是PTE的缓存。

==当处理器第一次查找一个虚拟地址时，硬件通过3级page table得到最终的PPN，TLB会保存虚拟地址到物理地址的映射关系。==这样下一次当你访问同一个虚拟地址时，处理器可以查看TLB，TLB会直接返回物理地址，而不需要通过page table得到结果。

![](<../.gitbook/assets/image (402).png>)

### 学生提问

#### 切换page table，TLB缓存会清空

> 学生提问：前面说TLB会保存虚拟地址到物理地址的对应关系，如果在page级别做cache是不是更加高效？
>
> Frans教授：有很多种方法都可以实现TLB，对于你们来说最重要的是知道TLB是存在的。TLB实现的具体细节不是我们要深入讨论的内容。这是处理器中的一些逻辑，对于操作系统来说是不可见的，操作系统也不需要知道TLB是如何工作的。==你们需要知道TLB存在的唯一原因是，如果你切换了page table，操作系统需要告诉处理器当前正在切换page table，处理器会清空TLB。因为本质上来说，如果你切换了page table，TLB中的缓存将不再有用，它们需要被清空，否则地址翻译可能会出错。==所以操作系统知道TLB是存在的，但只会时不时的告诉操作系统，现在的TLB不能用了，因为要切换page table了。在RISC-V中，清空TLB的指令是sfence\_vma。

![](<../.gitbook/assets/image (181).png>)

#### 页表是硬件实现

> 学生提问：3级的page table是由操作系统实现的还是由硬件自己实现的？
>
> Frans教授：==这是由硬件实现的，所以3级 page table的查找都发生在硬件中。MMU是硬件的一部分而不是操作系统的一部分。==在XV6中，有一个函数也实现了page table的查找，因为时不时的XV6也需要完成硬件的工作，所以XV6有这个叫做walk的函数，它在软件中实现了MMU硬件相同的功能。
>
> 学生提问：在这个机制中，TLB发生在哪一步，是在地址翻译之前还是之后？
>
> Frans教授：整个CPU和MMU都在处理器芯片中，所以在一个RISC-V芯片中，有多个CPU核，MMU和TLB存在于每一个CPU核里面。RISC-V处理器有L1 cache，L2 Cache，有些cache是根据物理地址索引的，有些cache是根据虚拟地址索引的，由虚拟地址索引的cache位于MMU之前，由物理地址索引的cache位于MMU之后。
>
> 学生提问：之前提到，硬件会完成3级 page table的查找，那为什么我们要在XV6中有一个walk函数来完成同样的工作？
>
> Frans教授：非常好的问题。这里有几个原因，首先XV6中的walk函数设置了最初的page table，它需要对3级page table进行编程所以它首先需要能模拟3级page table。另一个原因或许你们已经在syscall实验中遇到了，在XV6中，内核有它自己的page table，用户进程也有自己的page table，用户进程指向sys\_info结构体的指针存在于用户空间的page table，但是内核需要将这个指针翻译成一个自己可以读写的物理地址。如果你查看copy\_in，copy\_out，你可以发现内核会通过用户进程的page table，将用户的虚拟地址翻译得到物理地址，这样内核可以读写相应的物理内存地址。这就是为什么在XV6中需要有walk函数的一些原因。
>
> 学生提问：为什么硬件不开发类似于walk函数的接口？这样我们就不用在XV6中用软件实现自己的接口，自己实现还容易有bug。为什么没有一个特殊权限指令，接收虚拟内存地址，并返回物理内存地址？
>
> Frans教授：其实这就跟你向一个虚拟内存地址写数据，硬件会自动帮你完成工作一样（工作是指翻译成物理地址，并完成数据写入）。你们在page table实验中会完成相同的工作。我们接下来在看XV6的实现的时候会看到更多的内容。

------

### ==补充：**页表是内核实现还是硬件实现？**==

**页表**的实现依赖于**操作系统内核和硬件（CPU/MMU）之间的协作**，所以可以认为它是一个**软硬件结合**的机制。具体来说：

#### **1. 页表的数据结构由内核实现**

- **页表的数据结构**（如多级页表的组织形式）是由操作系统的内核负责管理和维护的。不同的操作系统（如 Linux、Windows、macOS）在页表的实现细节上有所不同，但核心功能类似：用于**将虚拟地址映射到物理地址**。
- **内核的职责**：
  1. 在进程创建时，为该进程分配页表。
  2. 管理每级页表的创建、更新、回收，并处理 **Page Fault** 异常。
  3. 维护页表条目中的状态信息，如**访问权限、有效位、脏页位**等。

#### **2. 页表查找由硬件（MMU）执行**

- ==页表查找过程依赖于硬件中的 **MMU（Memory Management Unit，内存管理单元）**，这是 CPU 的一部分。**MMU 负责将虚拟地址翻译为物理地址**，并且与 **TLB（Translation Lookaside Buffer）** 配合提高查找效率。==
- **MMU 的职责**：
  1. 从 **SATP** 或类似的寄存器中读取页表的起始物理地址。
  2. 根据虚拟地址逐级查找页表，并找到对应的物理页。
  3. 如果页表条目无效或地址未映射，则触发**Page Fault**。

#### **3. 两者的协同工作过程**

- **CPU/MMU 负责地址转换**：当程序访问某个虚拟地址时，CPU 会通过 MMU 将其翻译为物理地址。
- **内核负责处理异常**：如果 MMU 在页表中找不到对应的映射地址，则触发 **Page Fault** 异常，转交给操作系统内核。内核会决定是**分配新的页面**还是终止进程。

#### **4. 为什么页表既涉及内核也涉及硬件？**

1. **性能需求**：虚拟地址到物理地址的转换需要非常快，因此**页表查找依赖于硬件（MMU）**。
2. **灵活性**：不同进程的页表需要动态管理，这由操作系统内核负责。因此**页表的创建和维护是内核的任务**。
3. **安全性**：操作系统通过内核控制页表的权限位（如只读、可执行），从而实现内存访问的隔离和保护。

#### **总结**

页表是一种**软硬件结合实现**的机制：

- **内核**：负责创建、更新、和管理页表的数据结构，并处理 Page Fault。
- **硬件（MMU）**：负责执行快速地址转换，通过读取页表将虚拟地址映射到物理地址。

这种设计确保了系统的**性能、灵活性和安全性**，实现了现代操作系统对虚拟内存的高效管理。

------





在我们介绍XV6之前，有关page table我还想说一点。用时髦的话说，page table提供了一层抽象（[level of indirection](https://en.wikipedia.org/wiki/Indirection)）。==我这里说的抽象就是指从虚拟地址到物理地址的映射。这里的映射关系完全由操作系统控制。==

![](<../.gitbook/assets/image (184).png>)

#### page table抽象 -> page fault -> 功能

因为操作系统对于这里的地址翻译有完全的控制，它可以实现各种各样的功能。比如，当一个PTE是无效的，硬件会返回一个page fault，对于这个page fault，操作系统可以更新 page table并再次尝试指令。所以，通过操纵page table，在运行时有各种各样可以做的事情。我们在之后有一节课专门会讲，当出现page fault的时候，操作系统可以做哪些有意思的事情。现在只需要记住，page table是一个无比强大的机制，它为操作系统提供了非常大的灵活性。这就是为什么page table如此流行的一个原因。



# 4.4 页表缓存（Translation Lookaside Buffer, TLB）详细总结

## 一、TLB的概念与作用

### 1. 多级页表查找的开销

- RISC-V的页表结构采用三级页表，每次地址翻译需要经过3次内存查找：
  1. 查找最高级的页目录（L2）。
  2. 查找中间级的页目录（L1）。
  3. 查找最低级的页目录（L0）。

- **问题**：每次访问一个虚拟地址都要多次访问内存，导致性能下降。

### 2. 页表缓存（TLB）的引入

- **TLB**是**PTE（Page Table Entry）**的缓存，用于存储最近使用过的虚拟地址与物理地址之间的映射。
- **TLB的优势**：如果访问过的虚拟地址存在于TLB中，处理器可以直接从TLB获取物理地址，而无需再次查询页表。

## 二、TLB的设计与管理

### 1. TLB的管理与清空

- **TLB的缓存机制**：每次地址翻译后，TLB会存储虚拟地址与物理地址的映射。
- **切换页表时**，操作系统需要**清空TLB**，防止错误的地址映射。
- 在**RISC-V**中，使用`sfence_vma`指令清空TLB。

- **操作系统与TLB的关系**：操作系统无需理解TLB的内部工作，只需在**切换页表**时通知处理器清空TLB。

## 三、三级页表的实现与XV6中的`walk`函数

### 1. 三级页表的实现

- **MMU（Memory Management Unit）**负责三级页表的查找，查找完全由硬件完成。
- 页表的三级结构：
  - **L2** 页目录 → **L1** 页目录 → **L0** 页目录 → 物理地址。

### 2. XV6中的`walk`函数

- XV6中有一个`walk`函数模拟了**硬件的页表查找逻辑**。
- 为什么需要`walk`函数：
  1. **初始化页表**：系统启动时，XV6需要手动设置3级页表。
  2. **跨页表访问**：内核需要使用`walk`函数将用户进程的虚拟地址转换为物理地址，方便内核访问用户进程的数据。

## 四、TLB、MMU和Cache的关系

### 1. TLB与MMU的位置

- **MMU**与TLB一起集成在**处理器芯片内**，每个**CPU核**都有自己的TLB和MMU。
- Cache的种类：
  - **L1 Cache** 和 **L2 Cache**：部分Cache基于虚拟地址索引，部分基于物理地址索引。
  - **TLB位于MMU之前**，用于缓存虚拟地址到物理地址的映射。

## 五、页表的灵活性与抽象

### 1. 页表提供的抽象层次

- **页表**是一种**抽象层（Level of Indirection）**，实现虚拟地址与物理地址的映射。
- **操作系统完全控制**页表，因此可以在运行时灵活地操纵地址映射。

- **Page Fault的处理**：当硬件检测到**无效的PTE**时，会触发**page fault**，交由操作系统处理。操作系统可以更新页表后重试访问。

### 2. 页表的广泛应用

- 页表机制为操作系统提供了灵活性，可以实现多种高级功能：
  - 动态加载数据页。
  - 通过page fault实现内存换页和内存映射。

## 六、常见问题与回答

### 1. 为什么XV6需要实现`walk`函数？

- **原因1**：`walk`函数用于**初始化页表**。
- **原因2**：内核需要通过用户进程的页表，将用户虚拟地址映射为物理地址。

### 2. 为什么硬件不提供类似`walk`函数的接口？

- 硬件自动处理地址翻译，而软件实现`walk`函数是为了**特殊需求**，如手动设置页表或跨进程访问内存。

### 3. 为什么需要清空TLB？

- ==每次**切换页表**时，TLB中的缓存会变得无效，必须清空以避免错误的地址翻译。==

## 七、总结与思考

### 1. 页表缓存（TLB）的重要性

- TLB极大地提升了虚拟地址翻译的性能，避免频繁访问多级页表。

### 2. 页表的抽象与灵活性

- 页表为操作系统提供了极大的控制权和灵活性，可以根据需求**动态调整内存映射**。

### 3. 实验中的应用

- 在实验中，学生需要通过**walk函数**理解和实现页表的初始化与管理。
- **Page fault**的处理将在后续课程中详细介绍，这是一项重要的操作系统功能。

------

通过本节课程，我们深入理解了**TLB的工作原理、页表的灵活性与XV6中的实现**。这些知识对于操作系统的开发与调试至关重要，并且为接下来的**page table和page fault实验**打下了坚实的基础。
