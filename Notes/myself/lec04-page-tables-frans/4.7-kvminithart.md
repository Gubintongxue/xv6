# 4.7 kvminithart 函数

### kvminit->kvminithart

之后，kvminit函数返回了，在main函数中，我们运行到了kvminithart函数。

![](<../.gitbook/assets/image (255).png>)

#### kvminithart->设置SATP寄存器->使用虚拟内存地址，之前是物理内存

这个函数首先设置了SATP寄存器，kernel\_pagetable变量来自于kvminit第一行。==所以这里实际上是内核告诉MMU来使用刚刚设置好的page table==。当这里这条指令执行之后，下一个指令的地址会发生什么？

在这条指令之前，还不存在可用的page table，所以也就不存在地址翻译。执行完这条指令之后，程序计数器（Program Counter）增加了4。而之后的下一条指令被执行时，程序计数器会被内存中的page table翻译。

所以这条指令的执行时刻是一个非常重要的时刻。**因为整个地址翻译从这条指令之后开始生效，之后的每一个使用的内存地址都可能对应到与之不同的物理内存地址。因为在这条指令之前，我们使用的都是物理内存地址，这条指令之后page table开始生效，所有的内存地址都变成了另一个含义，也就是虚拟内存地址。**

这里能正常工作的原因是值得注意的。因为前一条指令还是在物理内存中，而后一条指令已经在虚拟内存中了。比如，==下一条指令地址是0x80001110就是一个虚拟内存地址。==

![](<../.gitbook/assets/image (321).png>)

为什么这里能正常工作呢？因为kernel page的映射关系中，虚拟地址到物理地址是完全相等的。所以，在我们打开虚拟地址翻译硬件之后，地址翻译硬件会将一个虚拟地址翻译到相同的物理地址。

所以实际上，我们最终还是能通过内存地址执行到正确的指令，因为经过地址翻译0x80001110还是对应0x80001110。

### 管理虚拟内存的一个难点->page table设置错误后果->page table实验（难）

管理虚拟内存的一个难点是，==一旦执行了类似于SATP这样的指令，你相当于将一个page table加载到了SATP寄存器，你的世界完全改变了。==现在每一个地址都会被你设置好的page table所翻译。那么假设你的page table设置错误了，会发生什么呢？有人想回答这个问题吗？

> 学生A回答：你可能会覆盖kernel data。
>
> 学生B回答：会产生page fault。

是的，因为page table没有设置好，虚拟地址可能根本就翻译不了，那么内核会停止运行并panic。所以，如果page table中有bug，你将会看到奇怪的错误和崩溃，这导致了page table实验将会比较难。如果你不够小心，或者你没有完全理解一些细节，你可能会导致kernel崩溃，这将会花费一些时间和精力来追踪背后的原因。但这就是管理虚拟内存的一部分，因为对于一个这么强大的工具，如果出错了，相应的你也会得到严重的后果。我并不是要给你们泼凉水，哈哈。另一方面，这也很有乐趣，**经过了page table实验，你们会真正理解虚拟内存是什么，虚拟内存能做什么。**





------



# 4.7 `kvminithart` 函数详细总结

## 一、`kvminithart` 的作用与重要性

- ==**`kvminithart`** 函数在 **`main`** 函数中调用，用于设置 **SATP寄存器**，将 **内核页表加载到MMU** 中，正式启用虚拟内存。==

- 这是内核初始化过程中一个**关键步骤**，因为在此之后，CPU开始使用**虚拟地址进行地址翻译**。

## 二、SATP寄存器的设置与地址翻译的生效

### 1. SATP寄存器的作用

- ==SATP（Supervisor Address Translation and Protection）寄存器用于指示MMU使用哪个page table进行地址翻译。==
  - 在 **`kvminit`** 函数中分配并初始化的**`kernel_pagetable`** 是这里使用的page table。

```
w_satp(SATP_SV39, kernel_pagetable);
```

- **程序计数器（PC）**在此刻变得重要：
  - 之前，PC 使用的地址都是**物理地址**。
  - **加载SATP寄存器后**，PC会指向**虚拟地址**，MMU通过page table将其翻译为物理地址。

------

### 2. 虚拟地址与物理地址的同步

- 由于**虚拟地址与物理地址一对一映射**，即使切换到虚拟内存后，虚拟地址与物理地址保持一致，因此内核代码能继续正常运行。

```
虚拟地址：0x80001110 → 物理地址：0x80001110
```

- SATP指令执行后的转变：
  - 之前的指令在**物理地址空间**中执行。
  - 之后的指令在**虚拟地址空间**中执行，并通过MMU转换为物理地址。

## 三、虚拟内存管理中的挑战

### 1. SATP切换后的潜在问题

- **虚拟内存开启后**，每一个地址都需要经过**page table的翻译**。
- 若page table配置错误：
  1. **Page fault** 发生：内核会停止并触发 **panic**。
  2. 错误的地址映射可能会覆盖 **kernel data**。

> **学生讨论**：
>
> - 学生A：可能会覆盖内核数据。
> - 学生B：会产生page fault。

### 2. 追踪page table错误的困难

- 管理虚拟内存的复杂性：
  - 一旦错误发生，可能会导致系统崩溃，且错误难以追踪。
  - 学生需要仔细理解 **虚拟地址映射机制**，确保page table的正确性。

## 四、实验中的挑战与乐趣

### 1. 虚拟内存实验的复杂性

- **page table实验** 可能会出现许多奇怪的错误和崩溃，需要投入时间来**追踪错误**。
- 但通过实验，学生可以真正理解虚拟内存的**强大功能和实现细节**。

### 2. 学习的收获

- 尽管实验有一定难度，但掌握了虚拟内存后，学生将：
  - 深刻理解 **虚拟地址与物理地址的映射机制**。
  - 掌握 **MMU和SATP寄存器** 的工作原理。
  - 学会如何调试和解决虚拟内存相关的复杂问题。

## 五、总结与思考

### 1. `kvminithart` 的核心作用

- `kvminithart` 通过设置 **SATP寄存器**，将内核页表加载到 **MMU**，正式启用 **虚拟地址翻译**。

### 2. SATP切换的影响

- 在启用虚拟内存后，**每个地址都必须通过page table翻译**。如果配置错误，可能导致 **page fault** 或数据损坏。

### 3. 实验中的挑战与乐趣

- 学生需要在实验中谨慎配置page table，并通过调试学习 **虚拟内存** 的工作机制。这将帮助学生深入理解操作系统的**内存管理核心原理**。

本节课详细解析了 **`kvminithart` 函数** 的作用及其在 **启用虚拟内存** 中的重要性。通过实验，学生将掌握如何管理虚拟内存，并应对可能的错误和挑战。这些知识对操作系统开发至关重要。
