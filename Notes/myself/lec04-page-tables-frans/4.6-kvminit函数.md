# 4.6 kvminit 函数

接下来，让我们看一看代码，我认为很多东西都会因此变得更加清晰。

首先，我们来做一个的常规操作，启动我们的XV6，这里QEMU实现了主板，同时我们打开gdb。

![](<../.gitbook/assets/image (209).png>)

### kvminit代码

上一次我们看了boot的流程，我们跟到了main函数。main函数中调用的一个函数是kvminit（注，详见3.9），这个函数会设置好kernel的地址空间。kvminit的代码如下图所示：

![](<../.gitbook/assets/image (356).png>)

#### kmalloc()为最高级page dirctory分配物理页

我们在前一部分看了kernel的地址空间长成什么样，这里我们来看一下代码是如何将它设置好的。首先在kvminit中设置一个断点，之后运行代码到断点位置。在gdb中执行layout split，可以看到（从上面的代码也可以看出）函数的==第一步是为最高一级page directory分配物理page（注，调用kalloc就是分配物理page）。==下一行将这段内存初始化为0。

![](<../.gitbook/assets/image (197).png>)

#### kvmmap()

==之后，通过kvmmap函数，将每一个I/O设备映射到内核。==例如，下图中高亮的行将UART0映射到内核的地址空间。

![](<../.gitbook/assets/image (261).png>)

我们可以查看一个文件叫做memlayout.h，它将4.5中的文档翻译成了一堆常量。在这个文件里面可以看到，UART0对应了地址0x10000000（注，4.5中的文档是真正SiFive RISC-V的文档，而下图是QEMU的地址，所以4.5中的文档地址与这里的不符）。

![](<../.gitbook/assets/image (265).png>)

==所以，通过kvmmap可以将物理地址映射到相同的虚拟地址（注，因为kvmmap的前两个参数一致）。==

在page table实验中，第一个练习是实现vmprint，这个函数会打印当前的kernel page table。我们现在跳过这个函数，看一下执行完第一个kvmmap时的kernel page table。

![](<../.gitbook/assets/image (328).png>)

### 查找过程

我们来看一下这里的输出。第一行是最高一级page directory的地址，这就是存在SATP或者将会存在SATP中的地址。第二行可以看到最高一级page directory只有一条PTE序号为0，它包含了中间级page directory的物理地址。第三行可以看到中间级的page directory只有一条PTE序号为128，它指向了最低级page directory的物理地址。第四行可以看到最低级的page directory包含了PTE指向物理地址。你们可以看到最低一级 page directory中PTE的物理地址就是0x10000000，对应了UART0。

前面是物理地址，我们可以从虚拟地址的角度来验证这里符合预期。我们将地址0x10000000向右移位12bit，这样可以得到虚拟地址的高27bit（index部分）。之后我们再对这部分右移位9bit，并打印成10进制数，可以得到128，这就是中间级page directory中PTE的序号。这与之前（4.4）介绍的内容是符合的。

![](<../.gitbook/assets/image (353).png>)

从标志位来看（fl部分），最低一级page directory中的PTE有读写标志位，并且Valid标志位也设置了（4.3底部有标志位的介绍）。

内核会持续的按照这种方式，调用kvmmap来设置地址空间。之后会对VIRTIO0、CLINT、PLIC、kernel text、kernel data、最后是TRAMPOLINE进行地址映射。最后我们还会调用vmprint打印完整的kernel page directory，可以看出已经设置了很多PTE。

![](<../.gitbook/assets/image (320).png>)

这里就不过细节了，但是这些PTE构成了我们在4.5中看到的地址空间对应关系。

（下面问答来自课程结束部分，因为内容相关就移到这里。）

### 学生提问

> 学生：下面这两行内存不会越界吗？

![](<../.gitbook/assets/image (377).png>)

> Frans：不会。这里KERNBASE是0x80000000，这是内存开始的地址。kvmmap的第三个参数是size，etext是kernel text的最后一个地址，etext - KERNBASE会返回kernel text的字节数，我不确定这块有多大，大概是60-90个page，这部分是kernel的text部分。PHYSTOP是物理内存的最大位置，PHYSTOP-text是kernel的data部分。会有足够的DRAM来完成这里的映射。



## 拓展

### **补充：页表在物理内存中的分配及内核的控制方式**

页表是**虚拟内存到物理内存映射**的核心结构。在现代操作系统中，**页表**是存储在**物理内存**中的，但它的创建、分配、更新和管理由**内核**负责。以下详细说明页表在物理内存中的分配过程及内核如何控制这一过程。

#### **1. 页表在物理内存中的分配过程**

1. **物理页的分配：**
   - 页表本质上是一个**数据表**，它占用一定的物理内存。通常，每张页表占用一个**4KB 大小的页面**，因为页大小通常为 4KB（具体大小取决于体系结构）。
   - **当进程创建或扩展时**，内核会从**Free Memory（空闲物理内存块）**中为页表分配页面。
2. **页表条目（PTE，Page Table Entry）：**
   - 每个页表条目（PTE）映射一个虚拟页面到物理页面的地址。
   - **一张页表**（4KB）可以存储 512 个 PTE（在 64 位系统上，每个 PTE 8 字节）。
3. **多级页表的使用：**
   - 现代系统采用**多级页表**（如二级、三级或四级页表）来管理内存，减少页表占用的空间。每一级页表都需要占用一个 4KB 页面，因此多级结构需要多个页面进行分配。

#### **2. 内核如何控制页表的分配与管理**

1. **页表创建：**
   - 当内核创建一个新进程时，内核首先为该进程分配一个**根页表**（即最高级页表）。这张页表会被写入**MMU 的控制寄存器**，如 RISC-V 架构的 **SATP** 寄存器或 x86 架构的 **CR3** 寄存器。
   - 如果一个进程需要访问更多内存地址（超出当前页表范围），内核会为下一层级的页表再分配新的页面。
2. **使用伙伴系统（Buddy System）管理页表的分配：**
   - 内核通常使用 **Buddy System** 来管理物理页面的分配。Buddy System 会分配大小为 4KB 的页面，以满足页表的内存需求。
3. **处理 Page Fault（缺页异常）：**
   - 当进程尝试访问未映射的虚拟地址时，MMU 会触发 Page Fault 异常。内核捕获该异常，并动态**为该虚拟地址分配物理页面和更新页表**。
4. **页表更新与刷新 TLB：**
   - 当页表条目发生变化（例如新映射的物理页面），内核会更新页表，并刷新 **TLB（Translation Lookaside Buffer）**，确保 MMU 使用最新的映射。
5. **地址空间切换：**
   - 每次**进程切换**时，内核会将该进程的根页表地址加载到 **SATP 或 CR3 寄存器**，使得 MMU 能够使用该进程的地址空间。

#### **3. 页表管理的关键点**

1. **分配策略：**
   - 页表分配的每一层级都是按需进行的，未使用的虚拟地址部分不会分配相应的页表页面，节省物理内存。
2. **权限管理：**
   - 页表条目中包含权限信息（如读、写、执行权限）。内核根据进程的需求设置页表的访问权限，并在**非法访问时触发异常**。
3. **共享内存与映射：**
   - 在某些情况下，内核会将**多个进程的虚拟地址映射到相同的物理页面**（如共享库），这提高了内存利用率。

#### **4. 小结**

页表是存储在**物理内存**中的关键结构，由内核负责创建和管理。具体过程包括：

1. **分配**：内核通过伙伴系统分配页表页面。
2. **维护**：当虚拟地址需要映射时，内核更新页表条目并刷新 TLB。
3. **异常处理**：在 Page Fault 时，内核为虚拟地址分配物理页面并更新页表。

这种设计确保了**虚拟地址到物理地址的高效转换**，同时支持**内存隔离**、**按需分配**和**内存共享**等特性。

------







# 4.6 `kvminit` 函数详细总结

## 一、`kvminit`函数概述

- **`kvminit`** 是 XV6 中用于设置**内核地址空间**的重要函数。
- 主流程：
  1. 为最高级的 **page directory** 分配内存。
  2. 使用 **`kvmmap`** 函数，将内核与 I/O 设备等物理地址映射到虚拟地址。

------

## 二、`kvminit`的代码解析

### 1. 为Page Directory分配物理内存

- 通过**`kalloc`** 分配一个物理页作为**最高级 page directory**，并将其**初始化为0**：

```
pml4 = (pagetable_t) kalloc(); // 分配物理页
memset(pml4, 0, PGSIZE); // 初始化为0
```

- **SATP寄存器**会保存这个page directory的地址，完成映射后，它将被加载到寄存器中。

------

### 2. 使用`kvmmap`函数设置地址映射

- **`kvmmap`** 函数将**物理地址映射到虚拟地址**，例如将 **UART0** 映射到虚拟地址空间：

```
kvmmap(UART0, UART0, PGSIZE, PTE_R | PTE_W);
```

- 地址映射示例：

  - 在 `memlayout.h` 文件中定义了常量：

    ```
    #define UART0 0x10000000
    ```

  - **QEMU** 模拟的 UART0 设备地址与 **SiFive RISC-V** 文档中的地址略有不同。

------

### 3. `kvmmap`映射后的Page Table输出

- 执行完kvmmap后，使用vmprint函数打印kernel page table：
  1. 第一行：最高级 page directory 的物理地址。
  2. 第二行：最高级 page directory 的 **PTE** 指向中间级 page directory。
  3. 第三行：中间级 page directory 的 PTE 序号 **128**。
  4. 第四行：最低级 page directory 的 PTE 指向物理地址 **0x10000000**，对应 **UART0**。

- 地址计算：
  - 将地址 **0x10000000** 右移 12bit 得到虚拟地址的高 **27bit**。
  - 再右移 9bit，得到中间级 page directory 中 PTE 的序号：**128**。

------

## 三、持续映射其他关键地址

- `kvmmap`

   被多次调用，映射以下关键内存区域：

  1. **VIRTIO0**：虚拟磁盘设备。
  2. **CLINT / PLIC**：中断控制器。
  3. **Kernel Text & Data**：内核代码段与数据段。
  4. **TRAMPOLINE**：用于内核与用户进程之间的上下文切换。

## 四、地址空间与映射规则的讨论

### 1. 虚拟地址和物理地址的等价映射

- 在 XV6中，虚拟地址和物理地址一对一映射。例如：

  ```
  kvmmap(UART0, UART0, PGSIZE, PTE_R | PTE_W);
  ```

  - 虚拟地址和物理地址均为 **0x10000000**，这简化了内核代码。

### 2. Kernel Stack 与 Guard Page

- **Kernel Stack** 被映射了两次：
  1. 在高地址虚拟内存区域映射一次（有 Guard Page）。
  2. 在低地址区域（PHYSTOP 下）映射一次。
- **Guard Page** 机制：
  - Guard Page 的 **Valid位未设置**，防止堆栈溢出时导致内存污染。

## 五、关于内存分配的问答

### 1. 内核地址空间是否越界？

- **KERNBASE**：表示内存开始地址 **0x80000000**。
- **`etext - KERNBASE`** 计算 **kernel text** 的大小（通常为 **60-90 个 page**）。
- 内核代码与数据段之间有足够的空间，确保不会越界。

### 2. 用户进程如何使用Free Memory？

- 用户进程的 **page table、代码段、数据段** 存储在 **Free Memory** 中。
- 当用户进程数量过多，Free Memory 耗尽时，`fork` 或 `exec` 会返回错误。

## 六、总结与思考

### 1. `kvminit` 的核心作用

- **`kvminit`** 函数通过**分配内存并建立映射**，初始化了 **内核地址空间**。
- 使用 **`kvmmap`** 将设备与内存区域映射到虚拟地址空间，确保系统正常访问 I/O 设备和内核资源。

### 2. 关键机制与优化

- **Guard Page** 提供了安全性，防止内存溢出导致数据污染。
- **虚拟地址和物理地址的等价映射** 简化了 XV6 的实现。

### 3. 学生实验的应用

- 学生将在 **page table 实验**中实现地址映射与虚拟内存打印，并优化多进程内存管理。
- 通过本节学习，学生将理解 **内核地址空间** 的布局与 **`kvminit`** 函数的关键作用。

------

本节课深入分析了 **`kvminit` 函数** 如何初始化 **XV6 内核地址空间**，并通过代码示例展示了虚拟地址和物理地址的映射方式。这些知识为学生理解操作系统内存管理的核心原理打下了坚实的基础。
