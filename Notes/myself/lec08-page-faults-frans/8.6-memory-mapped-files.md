# 8.6 Memory Mapped Files

这节课最后要讨论的内容，也是后面的一个实验，就是memory mapped files。这里的核心思想是，将完整或者部分文件加载到内存中，这样就可以通过内存地址相关的load或者store指令来操纵文件。为了支持这个功能，一个现代的操作系统会提供一个叫做mmap的系统调用。这个系统调用会接收一个虚拟内存地址（VA），长度（len），protection，一些标志位，一个打开文件的文件描述符，和偏移量（offset）。

![](<../.gitbook/assets/image (810).png>)

这里的语义就是，从文件描述符对应的文件的偏移量的位置开始，映射长度为len的内容到虚拟内存地址VA，同时我们需要加上一些保护，比如只读或者读写。

假设文件内容是读写并且内核实现mmap的方式是eager方式（不过大部分系统都不会这么做），内核会从文件的offset位置开始，将数据拷贝到内存，设置好PTE指向物理内存的位置。之后应用程序就可以使用load或者store指令来修改内存中对应的文件内容。当完成操作之后，会有一个对应的unmap系统调用，参数是虚拟地址（VA），长度（len）。来表明应用程序已经完成了对文件的操作，在unmap时间点，我们需要将dirty block写回到文件中。我们可以很容易的找到哪些block是dirty的，因为它们在PTE中的dirty bit为1。

![](<../.gitbook/assets/image (672).png>)

当然，在任何聪明的内存管理机制中，所有的这些都是以lazy的方式实现。你不会立即将文件内容拷贝到内存中，而是先记录一下这个PTE属于这个文件描述符。相应的信息通常在VMA结构体中保存，VMA全称是Virtual Memory Area。例如对于这里的文件f，会有一个VMA，在VMA中我们会记录文件描述符，偏移量等等，这些信息用来表示对应的内存虚拟地址的实际内容在哪，这样当我们得到一个位于VMA地址范围的page fault时，内核可以从磁盘中读数据，并加载到内存中。所以这里回答之前一个问题，dirty bit是很重要的，因为在unmap中，你需要向文件回写dirty block。

> 学生提问：有没有可能多个进程将同一个文件映射到内存，然后会有同步的问题？
>
> Frans教授：好问题。这个问题其实等价于，多个进程同时通过read/write系统调用读写一个文件会怎么样？
>
> 这里的行为是不可预知的。write系统调用会以某种顺序出现，如果两个进程向一个文件的block写数据，要么第一个进程的write能生效，要么第二个进程的write能生效，只能是两者之一生效。在这里其实也是一样的，所以我们并不需要考虑冲突的问题。
>
> 一个更加成熟的Unix操作系统支持锁定文件，你可以先锁定文件，这样就能保证数据同步。但是默认情况下，并没有同步保证。
>
> 学生提问：mmap的参数中，len和flag是什么意思？
>
> Frans教授：len是文件中你想映射到内存中的字节数。prot是read/write。flags会在mmap lab中出现，我认为它表示了这个区域是私有的还是共享的。如果是共享的，那么这个区域可以在多个进程之间共享。
>
> 学生提问：如果其他进程直接修改了文件的内容，那么是不是意味着修改的内容不会体现在这里的内存中？
>
> Frans教授：是的。但是如果文件是共享的，那么你应该同步这些变更。我记不太清楚在mmap中，文件共享时会发生什么。

你们会在file system lab之后做这里相关的mmap lab，这将会是我们最后一个虚拟内存实验。

最后来总结一下最近几节课的内容，我们首先详细看了一下page table是如何工作的，之后我们详细看了一下trap是如何工作的。而page fault结合了这两部分的内容，可以用来实现非常强大且优雅的虚拟内存功能。我们这节课介绍的内容，只是操作系统里面基于page fault功能的子集。一个典型的操作系统实现了今天讨论的所有内容，如果你查看Linux，它包含了所有的内容，以及许多其他有趣的功能。今天的内容希望能给让你们理解，一旦你可以在page fault handler中动态的更新page table，虚拟内存将会变得有多强大。



------



# **8.6 Memory Mapped Files**

在这部分内容中，我们讨论了**Memory Mapped Files**（内存映射文件），这是现代操作系统的重要功能。==内存映射文件允许将文件的一部分或全部内容映射到内存，通过虚拟内存地址进行访问和修改。==这种方式使得文件操作变得高效，并且能通过简单的load和store指令操作文件内容。接下来，我们详细总结mmap系统调用的概念、工作原理、挑战和实际应用。

### **1. mmap 系统调用的工作原理**

==**mmap**（Memory Map）是操作系统提供的系统调用，核心思想是将文件的内容映射到虚拟内存地址。==mmap系统调用的主要参数包括：

- **虚拟地址（VA）**：内存映射的起始虚拟地址。
- **长度（len）**：映射的文件内容大小（字节数）。
- **保护（protection）**：定义该内存区域的访问权限（如只读、读写）。
- **文件描述符（fd）**：表示要映射的文件。
- **偏移量（offset）**：表示映射文件时的起始位置。

当调用mmap时，操作系统会将文件内容映射到指定虚拟地址。应用程序可以通过操作该地址直接读写文件内容，而不需要额外的I/O系统调用。

### **2. eager 和 lazy 映射方式**

映射文件到内存有两种方式：

- **Eager 映射**：文件内容立即加载到物理内存并建立映射。
- ==**Lazy 映射**：文件内容不会立即加载。只有当用户访问该内存地址时，才会触发**page fault**，并在page fault handler中将文件的相关部分加载到内存。==这种方式更高效，并减少了不必要的物理内存占用。

### **3. Memory Mapped Files 的实现流程**

1. ==**mmap**调用会将文件内容的虚拟地址与物理内存建立映射，同时记录映射关系在内核的**VMA（Virtual Memory Area）**结构中。==
2. **Page Fault 触发**：当用户访问未加载的文件部分时，会触发page fault。
3. 处理Page Fault：
   - 从文件读取相应数据块并加载到物理内存。
   - 更新page table，并标记PTE的dirty位，以表示该page内容已修改。
4. **Unmap**：当文件操作结束时，通过**unmap**调用释放内存，并将dirty block写回文件。

### **4. 多进程文件映射中的挑战**

多个进程可能同时映射同一个文件，这引发了文件同步问题：

- **共享访问**：当两个进程同时读写同一个文件区域时，没有同步机制的话，数据修改的顺序无法预知。
- **解决方法**：通过文件锁机制（如Unix系统中的**flock**）保证同步，但默认情况下没有同步保障。

### **5. mmap 的系统调用参数**

- **len**：表示需要映射的文件部分的大小。
- **prot（protection）**：设置映射区域的权限，如只读、读写等。
- **flags**：标记映射的区域是否共享（如进程间共享）或私有。

### **6. mmap 中的dirty bit 和 VMA**

- ==**Dirty Bit**：PTE中的标志位，用于记录某个page是否被修改。当调用unmap时，内核会检查dirty bit，将修改过的page写回文件。==
- **VMA 结构**：Virtual Memory Area记录了文件描述符、偏移量、映射的虚拟地址范围等信息，帮助内核管理内存映射。

### **7. 性能与优化的权衡**

- **优势**：mmap提高了文件操作的效率，减少了系统调用的次数，使得应用程序可以更快启动。
- **缺点**：page fault会增加一定的开销，因为每次未命中都会进入内核进行处理。尽管有额外开销，但对于大文件或复杂应用来说，这种映射方式依然更高效。

### **8. 问答环节**

1. **问：多个进程共享文件时的同步问题如何处理？**
   **答**：==默认情况下没有同步保障，多个进程可能会覆盖彼此的修改。可以通过文件锁定机制保证同步。==
2. **问：mmap的flags参数表示什么？**
   **答**：flags参数用于指定映射区域的共享性，如是否在多个进程之间共享。
3. **问：如果文件在映射后被其他进程修改，会更新映射内容吗？**
   **答**：不会，除非映射是共享的。否则修改不会反映在映射区域中。

### **9. 总结**

Memory Mapped Files（内存映射文件）结合了**page fault**和**虚拟内存**的强大功能，使得文件操作变得高效且灵活。通过mmap，文件内容可以直接映射到内存，并通过简单的load和store指令操作文件。虽然这种方式引入了page fault带来的开销，但它减少了系统调用，并提升了程序的交互性能。在实际操作系统中，如Linux，mmap是非常重要的工具。你们将在mmap实验中实现这一功能，并体验其强大的作用。

### **课程总结**

经过几节课的学习，我们了解了**page table**的工作原理和**trap机制**的详细实现。**Page fault**机制结合了这两部分内容，成为实现虚拟内存功能的基础。**Lazy allocation**、**Zero-fill-on-demand**、**Copy-on-write Fork**和**Memory Mapped Files**等高级功能都是通过动态更新page table和处理page fault来实现的。现代操作系统如Linux，除了这些功能，还实现了许多其他强大的内存管理技术。通过理解和掌握这些技术，你们将能深入了解虚拟内存的强大潜力。



------



## 拓展

### 补充：为什么使用mmap，他和一般的程序变量到物理内存的过程有什么区别

`mmap` 是一种直接将文件内容映射到内存的方法，主要用于**高效地将文件数据映射为内存地址**，便于文件操作，同时支持共享和持久化。与一般程序变量的物理内存分配过程相比，`mmap` 有以下显著的特点和区别：

#### **1. `mmap` 的内存映射与普通变量的分配方式**

- **普通变量分配**：
  - 程序中的普通变量通过栈、堆、数据段等虚拟内存区域分配到物理内存。这些分配在程序运行时由操作系统管理，通常由编译器或 `malloc` 等库函数来处理。
  - 普通变量在内存中的映射是**私有的**，通常不能直接反映文件内容，也不会自动同步到文件。
- **`mmap` 的内存映射**：
  - `mmap` 将文件内容直接映射到进程的虚拟地址空间，即将文件内容的一部分（或全部）与虚拟内存区域一一对应。
  - `mmap` 的映射区域通过**多级页表**和内核中的 VMA（Virtual Memory Area）记录的映射关系管理，且与文件物理存储的页面直接关联。
  - `mmap` 允许对文件数据的修改**直接反映在文件中**，而不需要额外的写操作（当设置 `MAP_SHARED` 标志时）。

#### **2. 页面管理与映射差异**

- **普通变量的物理内存分配**：
  - 普通变量的内存分配在堆或栈中，内核通常先将虚拟地址映射到空闲的物理内存页，且没有文件关联。
  - 当变量首次被访问时（例如读写操作），内核分配物理内存并建立虚拟内存到物理内存的页表映射。
- **`mmap` 的页面管理**：
  - `mmap` 会在 VMA 中记录映射关系，使内核将对应的文件物理页与虚拟内存页面关联。
  - 当访问 `mmap` 区域时，如果该页面尚未加载到内存，会触发 Page Fault，内核会从文件中**按需加载页面**到内存，并建立虚拟到物理地址的映射。
  - 这种按需映射减少了初始内存占用，且可以映射到不同进程（例如共享内存和多进程读写同一文件）。

#### **3. 读写同步与共享**

- **普通变量的生命周期与隔离**：
  - 普通变量只在进程私有的内存空间中生效，其他进程无法直接访问或共享这些变量的内存内容。
  - 当进程结束时，普通变量的内存被释放且不影响外部文件。
- **`mmap` 的共享和同步特性**：
  - `mmap` 支持共享（`MAP_SHARED`）和私有映射（`MAP_PRIVATE`）。`MAP_SHARED` 使得多个进程可以映射同一文件的内容，且对该内存区域的写入会直接同步到文件中。
  - `mmap` 通过 `msync()` 可以强制将内存修改同步到文件，便于文件读写的一致性管理。

#### **4. 性能优势**

- `mmap` 减少了系统调用的开销：
  - 使用 `mmap` 映射文件，可以直接通过内存读写访问文件内容，而不必每次通过 `read()` 或 `write()` 系统调用读取或写入文件内容。
  - 这显著减少了系统调用开销，特别适合大文件或频繁访问的文件。

#### **总结**

`mmap` 提供了一个高效的方式，将文件映射到虚拟地址空间中，使文件操作如同内存操作一样便捷。相比普通程序变量，`mmap` 的内存分配基于内核的页表管理，并支持文件共享、直接同步和按需加载。通过 `mmap`，可以有效降低文件 I/O 操作的开销，提高文件数据的访问效率。

```

```

