# 13.7 wait系统调用

通过Unix的exit和wait系统调用的说明，我们可以知道如果一个进程exit了，并且它的父进程调用了wait系统调用，父进程的wait会返回。wait函数的返回表明当前进程的一个子进程退出了。所以接下来我们看一下wait系统调用的实现。

![](<../.gitbook/assets/image (591).png>)

它里面包含了一个大的循环。当一个进程调用了wait系统调用，它会扫描进程表单，找到父进程是自己且状态是ZOMBIE的进程。从上一节可以知道，这些进程已经在exit函数中几乎要执行完了。之后由父进程调用的freeproc函数，来完成释放进程资源的最后几个步骤。我们看一下freeproc的实现，

![](<../.gitbook/assets/image (493).png>)

这是关闭一个进程的最后一些步骤。如果由正在退出的进程自己在exit函数中执行这些步骤，将会非常奇怪。这里释放了trapframe，释放了page table。如果我们需要释放进程内核栈，那么也应该在这里释放。但是因为内核栈的guard page，我们没有必要再释放一次内核栈。不管怎样，当进程还在exit函数中运行时，任何这些资源在exit函数中释放都会很难受，所以这些资源都是由父进程释放的。

wait不仅是为了父进程方便的知道子进程退出，wait实际上也是进程退出的一个重要组成部分。在Unix中，对于每一个退出的进程，都需要有一个对应的wait系统调用，这就是为什么当一个进程退出时，它的子进程需要变成init进程的子进程。init进程的工作就是在一个循环中不停调用wait，因为每个进程都需要对应一个wait，这样它的父进程才能调用freeproc函数，并清理进程的资源。

当父进程完成了清理进程的所有资源，子进程的状态会被设置成UNUSED。之后，fork系统调用才能重用进程在进程表单的位置。

> 学生提问：在exit系统调用中，为什么需要在重新设置父进程之前，先获取当前进程的父进程？
>
> Robert教授：这里其实就是在防止一个进程和它的父进程同时退出。通常情况下，一个进程exit，它的父进程正在wait，一切都正常。但是也可能一个进程和它的父进程同时exit。所以当子进程尝试唤醒父进程，并告诉它自己退出了时，父进程也在退出。这些代码我一年前还记得是干嘛的，现在已经记不太清了。它应该是处理这种父进程和子进程同时退出的情况。如果不是这种情况的话，一切都会非常直观，子进程会在后面通过wakeup函数唤醒父进程。
>
> 学生提问：为什么我们在唤醒父进程之后才将进程的状态设置为ZOMBIE？难道我们不应该在之前就设置吗？
>
> Robert教授：正在退出的进程会先获取自己进程的锁，同时，因为父进程的wait系统调用中也需要获取子进程的锁，所以父进程并不能查看正在执行exit函数的进程的状态。这意味着，正在退出的进程获取自己的锁到它调用sched进入到调度器线程之间（注，因为调度器线程会释放进程的锁），父进程并不能看到这之间代码引起的中间状态。所以这之间的代码顺序并不重要。大部分时候，如果没有持有锁，exit中任何代码顺序都不能工作。因为有了锁，代码的顺序就不再重要，因为父进程也看不到进程状态。

这里我想要强调的是，直到子进程exit的最后，它都没有释放所有的资源，因为它还在运行的过程中，所以不能释放这些资源。相应的其他的进程，也就是父进程，释放了运行子进程代码所需要的资源。这样的设计可以让我们极大的精简exit的实现。





# 13.7 `wait` 系统调用

在 Unix 中，`exit` 系统调用让进程主动退出，而 `wait` 系统调用用于让父进程等待子进程的退出状态。`wait` 系统调用还承担着为退出的子进程清理资源的重要任务，保证子进程资源的完全释放。

## `wait` 系统调用的流程

`wait` 系统调用的实现包含了以下流程：

1. **遍历进程表**：父进程在 `wait` 中扫描进程表，寻找其子进程。若子进程的状态为 `ZOMBIE`，表示该子进程已经退出并等待资源释放。
2. **释放资源**：一旦找到状态为 `ZOMBIE` 的子进程，`wait` 中会调用 `freeproc`，完成资源的最终清理。

## `freeproc` 函数

`freeproc` 负责清理子进程的所有剩余资源，包括释放 `trapframe` 和 `page table`，并将进程的状态设为 `UNUSED`。当进程被标记为 `UNUSED` 后，它的进程表项可被 `fork` 系统调用重用。

在 `exit` 中不直接释放资源，而是由父进程在 `wait` 中负责资源清理，这一设计简化了退出进程的实现，使得进程的资源释放更加稳妥。

## `init` 进程的作用

在 Unix 系统中，每个退出的进程都需要由父进程的 `wait` 系统调用来清理资源。当父进程提前退出时，孤立的子进程会被重新指派给 `init` 进程作为其父进程。`init` 的职责是确保所有退出的子进程都能得到清理，因此 `init` 会在一个循环中持续调用 `wait`。

## 锁的使用与父子进程的同步

在 `wait` 的过程中涉及多个锁的使用，确保在多进程环境中，父子进程的状态和资源访问不会冲突：

- **父进程与子进程同步**：当子进程调用 `exit` 时，它会持有自己的锁，避免父进程在 `wait` 中看到进程未完全退出的中间状态。
- **避免资源竞争**：在 `exit` 和 `wait` 之间的资源清理任务被锁保护，使父进程在清理子进程资源时不会遇到竞态条件。

## 设计优势

通过将 `wait` 系统调用设计为退出进程的必要步骤，`XV6` 精简了 `exit` 的实现。让父进程负责子进程资源的清理，有助于减少进程退出中的资源管理问题，确保资源完全释放后，退出的进程才能被 `fork` 重用。
