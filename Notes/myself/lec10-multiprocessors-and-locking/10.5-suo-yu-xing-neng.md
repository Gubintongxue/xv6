# 10.5 锁与性能

我们前面已经看过了两类锁带来的挑战，一个是死锁，另一个是破坏了程序的模块化。这一部分来看看第三个挑战，也就是锁与性能之间的权衡。我们前面已经提过几次锁对性能的影响，但是因为这部分太重要了，我们再来详细的看一下。

基本上来说，如果你想获得更高的性能，你需要拆分数据结构和锁。如果你只有一个big kernel lock，那么操作系统只能被一个CPU运行。如果你想要性能随着CPU的数量增加而增加，你需要将数据结构和锁进行拆分。

那怎么拆分呢？通常不会很简单，有的时候还有些困难。比如说，你是否应该为每个目录关联不同的锁？你是否应该为每个inode关联不同的锁？你是否应该为每个进程关联不同的锁？或者是否有更好的方式来拆分数据结构呢？如果你重新设计了加锁的规则，你需要确保不破坏内核一直尝试维护的数据不变性。

如果你拆分了锁，你可能需要重写代码。如果你为了获得更好的性能，重构了部分内核或者程序，将数据结构进行拆分并引入了更多的锁，这涉及到很多工作，你需要确保你能够继续维持数据的不变性，你需要重写代码。通常来说这里有很多的工作，并且并不容易。

![](<../.gitbook/assets/image (484).png>)

所以这里就有矛盾点了。我们想要获得更好的性能，那么我们需要有更多的锁，但是这又引入了大量的工作。

通常来说，开发的流程是：

* 先以coarse-grained lock（注，也就是大锁）开始。
* 再对程序进行测试，来看一下程序是否能使用多核。
* 如果可以的话，那么工作就结束了，你对于锁的设计足够好了；如果不可以的话，那意味着锁存在竞争，多个进程会尝试获取同一个锁，因此它们将会序列化的执行，性能也上不去，之后你就需要重构程序。

在这个流程中，测试的过程比较重要。有可能模块使用了coarse-grained  lock，但是它并没有经常被并行的调用，那么其实就没有必要重构程序，因为重构程序设计到大量的工作，并且也会使得代码变得复杂。所以如果不是必要的话，还是不要进行重构。



------



# 10.5 锁与性能

本节课讨论了锁在多核并发环境中的性能影响，以及在追求性能优化时拆分锁的挑战。虽然锁保证了数据一致性，但若使用不当，会限制程序性能，尤其是在多核系统中。

## 1. 锁与性能的权衡

锁在并发处理中的一个主要问题是**性能瓶颈**。==若系统仅依赖于一个big kernel lock（单一的大锁），则同一时刻只有一个CPU能访问内核，无法充分利用多核优势。==因此，要使性能随着CPU核数增加而提升，必须对锁和数据结构进行合理的拆分。

- **性能瓶颈的原因**：==big kernel lock导致的序列化执行使得多核无法并行工作，阻碍性能提升。==
- **数据结构与锁的拆分**：==优化性能的核心在于为每个数据结构（如目录、inode或进程）设置独立的锁，使不同进程可以并行执行操作，而不必等待同一把锁的释放。==

## 2. 拆分锁的复杂性与不变性维护

尽管拆分锁能够提高性能，但其实现并不简单：

- **拆分带来的复杂性**：==为每个目录、inode或进程创建独立锁需要对数据结构进行细致的拆分，可能需要重新设计和重写代码，以确保不破坏内核的数据不变性。==
- **不变性维护**：在拆分锁的过程中，程序需要维持数据结构的一致性，这可能涉及大量代码重构。

这种性能优化方式既耗时，又易引入新的错误和复杂性。

## 3. 性能优化的基本流程

为了平衡开发效率与性能，通常采用以下优化流程：

1. **以粗粒度锁（coarse-grained lock）起步**：==初始设计中使用大锁，以保证程序正确性。==
2. **测试并行性**：在多核环境下测试程序，看其是否能够有效利用多核。如果程序在多核环境中没有出现明显的锁竞争，则锁的设计已足够好。
3. **必要时重构**：==若测试表明锁竞争频繁，导致多个进程争抢同一把锁、程序序列化执行，则需考虑重构程序，将大锁拆分为细粒度锁，以提升并行性能。==

在优化流程中，测试是关键步骤。仅在锁竞争频繁、阻碍并行执行时，才考虑拆分锁，避免不必要的复杂性。

## 4. 评估拆分锁的必要性

在特定模块中，若粗粒度锁能满足并行需求，并且并发调用不频繁，则无需进一步优化。因为拆分锁会增加代码复杂性，带来额外维护成本。若拆分锁无法显著提升性能，反而会使程序更难管理，则不值得投入过多精力进行优化。

------

综上，锁与性能之间的权衡需基于程序的实际需求和并发性。粗粒度锁简单且易于管理，但可能限制多核性能；而细粒度锁增加了并行性，但引入更多复杂性。在实践中，通过测试和渐进式优化来寻找合理的锁设计是提升性能的有效方法。
