# 5.6 Struct

今天我想讨论的最后一个话题是struct，stuct非常重要并且在课程的实验中会经常出现。我会稍微介绍一下struct在内存中的结构是怎样。基本上来说，struct在内存中是一段连续的地址，如果我们有一个struct，并且有f1，f2，f3三个字段。

![](<../.gitbook/assets/image (761).png>)

当我们创建这样一个struct时，内存中相应的字段会彼此相邻。你可以认为struct像是一个数组，但是里面的不同字段的类型可以不一样。（注，这应该是这一节中最有用的一句话了。。。）

我们可以将struct作为参数传递给函数。

![](<../.gitbook/assets/image (723).png>)

这里有一个名字是Person的struct，它有两个字段。我将这个struct作为参数传递给printPerson并打印相关的信息。我们在printPerson中设置一个断点，当程序运行到函数内部时打印当前的Stack Frame。

![](<../.gitbook/assets/image (673).png>)

我们可以看到当前函数有一个参数p。打印p可以看到这是struct Person的指针，打印p的反引用可以看到struct的具体内容。

![](<../.gitbook/assets/image (651).png>)

> 学生提问：是谁创建了编译器来将C代码转换成各种各样的汇编代码，是不同的指令集创建者，还是第三方？
>
> TA：我认为不是指令集的创建者，通常是第三方创建的。你们常见的两大编译器，一个是gcc，这是由GNU基金会维护的；一个是llvm，这个是开源的，你可以查到相应的代码。当一个新的指令集，例如RISC-V，发布之后，我认为会指令集的创建者和编译器的设计者之间会有一些高度合作。简单来说我认为是第三方配合指令集的创建者完成的编译器。RISC-V或许是个例外，因为它是来自于一个研究项目，相应的团队或许自己写了编译器，但是我不认为Intel对于gcc或者llvm有任何输入。

------



# 5.6 Struct（结构体）详细总结

## 一、Struct的概念与作用

- **Struct（结构体）** 是一种将**不同类型的数据组合**在一起的数据结构。
- 在 **内存中**，struct 的各个字段按**顺序连续存储**，类似于数组，但**字段类型可以不同**。

## 二、Struct的内存布局

### 1. Struct的内存结构

- **Struct内存布局**：
  - struct 中的字段（如 `f1`、`f2`、`f3`）在**内存中连续存储**。
  - **与数组的区别**：数组中所有元素类型相同，而 struct 中**字段类型不同**。
- **内存连续性**：struct 的所有字段在创建时，**紧邻排列在内存中的相邻地址上**。

## 三、Struct 作为参数传递

### 1. 示例：将 Struct 作为参数传递给函数

- **Person结构体**定义了两个字段：`name` 和 `age`。它作为参数传递给了 `printPerson` 函数用于打印。

  ```C
  struct Person {
      char* name;
      int age;
  };
  
  void printPerson(struct Person* p) {
      printf("Name: %s, Age: %d\n", p->name, p->age);
  }
  ```

### 2. 在 gdb 中查看 Struct 的信息

- **设置断点**：在 `printPerson` 函数中设置断点，程序暂停时查看 **Stack Frame**：

- 查看结构体指针：

  - 通过 **`info frame`** 查看当前函数参数，确认参数 **p** 是一个 **`Person` 结构体的指针**。

  - 反引用指针

     查看具体内容：

    ```
    p *p  # 打印结构体指针指向的具体内容
    ```

------

## 四、编译器与指令集的关系

> **学生提问**：谁创建了将 C 代码编译成汇编代码的编译器？是指令集的创建者还是第三方？

- TA 的回答：
  - 主流编译器：
    - **gcc**：由 **GNU基金会** 维护。
    - **llvm**：一个开源项目，其代码可以公开查看。
  - 指令集与编译器的合作：
    - 当新的指令集（如 RISC-V）发布时，指令集的创建者通常会与编译器开发者密切合作，为新指令集提供编译支持。
    - **例外情况**：RISC-V 作为研究项目，可能由其团队自行开发了部分编译器支持。
    - **Intel 与 gcc/llvm 的关系**：Intel 本身不参与 gcc 或 llvm 编译器的开发。

## 五、总结与思考

### 1. Struct的内存布局与应用

- **内存连续性**：Struct 将不同类型的数据按顺序存储，确保访问和操作的效率。
- **参数传递**：Struct 可以通过指针传递给函数，避免传递整个结构体的数据，提高性能。

### 2. 使用 gdb 调试 Struct 的技巧

- 在 gdb 中，通过 **设置断点** 和 **查看 Stack Frame**，可以追踪结构体的内容和内存布局。
- **反引用指针** 的操作对于深入理解结构体的内容和参数传递非常有用。

### 3. 编译器与指令集的协作

- 编译器的开发通常由**第三方**完成，但与指令集的创建者有一定合作。
- **开源编译器**（如 gcc 和 llvm）对新指令集的支持非常关键。

通过本节的学习，学生理解了 **Struct 的内存布局和参数传递机制**，掌握了在 **gdb 中调试 Struct** 的技巧。这些知识在未来的实验中将非常有用，特别是在**复杂数据结构和内存管理**的场景中。
