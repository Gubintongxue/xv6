# 5.1 C程序到汇编程序的转换

（00:00 - 05:25 在讨论syscall lab，没有什么实质内容故跳过）

今天的课程，我们会稍微讨论C语言转换到汇编语言的过程，以及处理器相关的内容。今天的课程更多偏向的是实际应用，或者至少我们的目标是这样。所以这节课的目标是让你们熟悉RISC-V处理器，汇编语言，以及RISC-V的calling convention。

对于page table来说这些内容不太重要，但是对于这周要发布的traps lab来说，这些内容至关重要，因为在这个实验中你们将会频繁用到trapframe（注，XV6中用来实现trap的一个内存page，lecture 6有详细内容）和栈。这些就是今天这节课的主要内容。

![](../.gitbook/assets/image5.1-01.png)

### C语言转化为汇编

我们首先来简单看一下C语言是如何转换成汇编语言的。这部分内容有点像是对你们之前学过的6.004或者任意其他计算机架构课程的简单回顾。

通常来说，我们的C语言程序会有一个main函数，假设在这个函数内你执行了一些打印然后退出了。

![](<../.gitbook/assets/image (689).png>)

目前看起来都还不错。但是如果你学过了6.004的话，你应该知道，处理器并不能理解C语言。处理器能够理解的是汇编语言，或者更具体的说，处理器能够理解的是==二进制编码之后的汇编代码。==

在下面这张图中，我从一个SiFive（注，一家基于RISC-V处理器的厂商）主板上圈出了一个实际的RISC-V处理器。

![](<../.gitbook/assets/image (687).png>)

==当我们说到一个RISC-V处理器时，意味着这个处理器能够理解RISC-V的指令集。所以，任何一个处理器都有一个关联的ISA（Instruction Sets Architecture），ISA就是处理器能够理解的指令集。==每一条指令都有一个对应的二进制编码或者一个Opcode。当处理器在运行时，如果看见了这些编码，那么处理器就知道该做什么样的操作。上图中的处理器正好能理解RISC-V汇编语言。

所以通常来说，要让C语言能够运行在你的处理器之上。==我们首先要写出C程序，之后这个C程序需要被编译成汇编语言。这个过程中有一些链接和其他的步骤，==但是因为这门课不是一个编译器的课程，所以我们忽略这些步骤。**之后汇编语言会被翻译成二进制文件也就是.obj或者.o文件。**

![](<../.gitbook/assets/image (716).png>)

如果你们曾经注意过你们的lab目录，在运行完_make  qemu_之后你会看到一些.o文件，这些就是处理器能够理解的文件。虽然你还没有写任何汇编程序，你们也可以在目录中看到一些.asm文件，这是由C语言编译生成的。如果你们学过了6.004，那么你们必然已经看过一些汇编语言。

汇编语言不具备C语言的组织结构，在汇编语言中你只能看到一行行的指令，比如add，mult等等。汇编语言中没有很好的控制流程，没有循环（注，但是有基于lable的跳转），虽然有函数但是与你们知道的C语言函数不太一样，汇编语言中的函数是以label的形式存在而不是真正的函数定义。汇编语言是一门非常底层的语言，许多其他语言，比如C++，都会编译成汇编语言。运行任何编译型语言之前都需要先生成汇编语言。

以上就是让计算机能够理解我们的C代码的基本流程。

------

## 拓展

### 补充：**处理器读取的是机器码（Machine Code），而不是汇编文件或 .o 文件**。

#### **1. 处理器的语言：机器码**

- **处理器只能直接执行机器码（Machine Code）**。机器码是**二进制指令**，这些指令是针对具体的 CPU 架构设计的。
- 汇编语言（`.asm` 文件）是人类可读的指令集，但它需要经过**汇编器（Assembler）**的处理，转化为机器码，才能被处理器执行。

#### **2. 汇编文件（`.asm` 文件）**

- 汇编语言文件（`.asm`）是开发人员写的源代码，描述了程序的**指令**、**寄存器**使用和**内存操作**。
- 这些文件需要通过**汇编器**转换成**二进制的机器码**。

**汇编过程：**

1. **汇编**：`.asm` 文件通过汇编器（如 GNU Assembler `as`）转换成目标文件（`.o`）。
2. **链接（Linking）**：多个 `.o` 文件通过链接器（`ld`）组合成一个可执行文件（`a.out` 或其他格式）。
3. **加载与执行**：操作系统将可执行文件加载到内存，供 CPU 执行。

#### **3. 目标文件（`.o` 文件）**

- **`.o` 文件**是编译器或汇编器生成的**目标文件**。它们包含**机器码**和其他符号信息（如未解析的地址）。
- **处理器无法直接执行 `.o` 文件**。这些文件必须经过**链接**过程，生成最终的**可执行文件**。

#### **4. 处理器执行的最终格式：机器码**

- **机器码**以二进制形式存储在**可执行文件**中。处理器通过**操作系统的加载程序**，将这些指令加载到内存，并按顺序执行。

#### **总结**

处理器**不能直接读取汇编语言文件（`.asm`）或目标文件（`.o`）**。它只能执行**机器码**，而机器码是汇编器生成的二进制指令。汇编代码和 `.o` 文件都是中间产物，必须经过一系列编译、汇编、链接和加载的步骤，才能转换成处理器可理解的机器码。

------

### ==补充：**为什么处理器需要 `.o` 文件生成的可执行文件？**==

**1. 从源代码到可执行文件的多步骤过程**

处理器只能直接执行**机器码**（二进制形式的指令）。然而，开发人员编写的源代码（如 C、C++、汇编代码等）必须经过多步转换才能生成这些二进制指令。这就涉及了**目标文件（`.o`）和可执行文件的生成**过程。
`.o` 文件和可执行文件是编译过程中重要的中间产物。具体原因如下：

#### **2. 编译和链接过程的必要性**

##### **2.1 什么是 `.o` 文件？**

- **`.o` 文件**是目标文件，是汇编器或编译器将源代码（如 C 或汇编代码）转化为**机器码片段**后的产物。每个 `.o` 文件包含一个模块的代码及其未解析的符号信息（如未定义的函数、全局变量等）。
- 这些 `.o` 文件还不是最终的可执行文件，需要进一步处理。

##### **2.2 链接（Linking）过程**

- 多个 `.o` 文件通过 **链接器（Linker）** 组合在一起，解析各个模块之间的**未定义符号**，并将代码和数据组合成一个**完整的可执行文件**。
- 链接器会将外部函数调用（如 `printf()`）与对应的库文件（如 C 标准库 `libc`）连接起来。

#### **3. 生成可执行文件的原因**

1. **完整性与独立性**：
   - 处理器只能运行**完整的可执行文件**。一个 `.o` 文件只是部分代码的机器码表示，并不包含其他模块或库的实现。必须经过**链接过程**生成完整的可执行文件。
2. **地址和符号解析**：
   - 在源代码和目标文件中，某些变量、函数地址等只是符号（Symbol）。链接器将这些符号解析为具体的地址或位置，以生成处理器能够理解的**最终机器码**。
3. **入口点（Entry Point）定义**：
   - 可执行文件定义了程序的**入口点**（如 `main()` 函数的地址），告诉操作系统和处理器从哪里开始执行。
4. **加载和执行的格式要求**：
   - 可执行文件包含了**加载信息**和**段信息**（如代码段、数据段）。操作系统的加载器根据这些信息将程序的不同部分加载到适当的内存地址，并准备执行。

#### **4. 处理器如何使用可执行文件？**

1. **操作系统的加载器负责加载可执行文件**：
   - 可执行文件由操作系统加载器解析，并将其加载到内存的合适位置。
   - 处理器从可执行文件中定义的入口点（`main()`）开始执行程序。
2. **执行中的虚拟内存映射**：
   - 可执行文件中的段信息（代码段、数据段）被映射到进程的虚拟地址空间，并由**MMU** 转换为物理地址。

#### **5. 小结**

- **`.o` 文件**是编译器生成的**中间产物**，其中包含部分机器码，但它们无法直接执行。必须通过**链接器**将多个 `.o` 文件和库组合成完整的可执行文件。
- **可执行文件**是完整的机器码，包含了所有符号解析和地址信息。操作系统加载器会将其加载到内存，并启动程序执行。

因此，处理器**只能执行机器码**，而**可执行文件**是保证这些机器码能够按预期运行的完整结构。

------

### ==补充：**处理器执行可执行文件，是在运行我们的程序吗？==**

**是的**，当处理器执行一个可执行文件时，它实际上是在运行我们编写的程序。这个过程涉及多个关键步骤，由操作系统和硬件共同完成。下面是详细的过程分析。

#### **1. 什么是可执行文件？**

- **可执行文件**是包含**机器码**和元信息的二进制文件，是程序最终的运行形式。这个文件由编译器、汇编器和链接器处理后生成，包含程序的指令、数据段、全局变量、以及入口点信息（如 `main()` 函数的地址）。
- 可执行文件通常具有不同的格式，如：
  - **ELF (Executable and Linkable Format)**：Linux 常用的格式。
  - **PE (Portable Executable)**：Windows 使用的格式。

#### 2. 可执行文件的加载与运行过程

1. **加载器（Loader）将可执行文件加载到内存**：
   - 当你在命令行或图形界面中运行一个程序时，操作系统的**加载器**会负责将可执行文件加载到内存中。
   - 加载器会解析可执行文件中的代码段、数据段、以及符号表等元信息，并将它们映射到内存的合适位置。
2. **初始化内存和进程结构**：
   - 加载器为程序分配必要的**虚拟地址空间**，并在内存中为栈（Stack）、堆（Heap）、代码段、数据段分配区域。
   - 操作系统也会初始化**进程控制块（PCB）**来管理程序的状态。
3. **设置入口点并切换到用户态**：
   - 加载器会找到可执行文件的**入口点**（如 `main()` 函数的地址），并将控制权交给处理器，从这里开始执行程序。
4. **处理器执行机器码**：
   - **处理器执行的是可执行文件中的机器码指令**。这些指令是源代码经过编译和汇编生成的，指示 CPU 执行诸如加法、跳转、函数调用等操作。

#### **3. 可执行文件运行的过程就是程序执行的过程吗？**

**是的**。当处理器从可执行文件的入口点开始执行指令时，它实际上就在运行你编写的程序。具体来说：

- **程序代码被转换为机器指令**：例如，`printf()` 在 C 代码中是一个系统调用。经过编译后，它变成了多条机器指令，告诉处理器如何将数据打印到屏幕。
- **程序逻辑依次执行**：处理器逐条执行你的程序代码对应的指令，包括循环、条件判断和函数调用。

#### **4. 操作系统的参与：进程与系统调用**

1. **进程管理**：
   - 每个运行的程序被操作系统视为一个**独立的进程**。操作系统管理这些进程的**调度**，决定哪个程序在何时获得 CPU 的执行权。
2. **系统调用**：
   - 当程序需要执行如**文件读写、网络通信**等操作时，会通过**系统调用**进入**内核态**，由操作系统完成这些操作。

#### **5. 小结**

当你运行一个可执行文件时，**处理器执行的就是你编写的程序的机器码**。这一过程由操作系统的加载器将可执行文件加载到内存，然后交给处理器执行。操作系统负责管理程序的资源和调度，但实际的代码逻辑由 CPU 按顺序执行。因此，处理器运行可执行文件的过程就是程序运行的过程。



------



# 5.1 C程序到汇编程序的转换详细总结

## 一、课程目标和背景

- 本节课探讨**C语言程序**如何转换成**汇编语言**，并解释RISC-V处理器如何理解指令。
- 这些知识虽然对 **page table** 影响不大，但对**traps lab** 至关重要，因为在该实验中需要操作 **trapframe** 和 **栈**。

------

## 二、处理器与指令集架构（ISA）

### 1. 汇编语言与处理器

- **处理器不能直接理解C语言**，它们需要理解**汇编语言**及其二进制编码形式。
- **RISC-V** 处理器采用**RISC-V指令集架构（ISA）**，每条指令对应一个**Opcode**。

- **ISA** 定义了处理器能够执行的所有指令集，RISC-V的处理器只能理解这些特定指令。

------

## 三、C语言转换成汇编语言的过程

### 1. C语言代码示例

```
int main() {
    printf("Hello, world!\n");
    return 0;
}
```

- C语言代码看起来结构化且易读，但这些代码**无法直接被处理器理解**。

### 2. 从C代码到二进制文件的转换步骤

1. **编写C程序**：C语言提供了高层抽象。
2. **编译成汇编语言**：C代码被翻译成汇编代码（如 `.asm` 文件）。
3. **汇编成二进制文件**：汇编代码被转换为**二进制文件**（如 `.obj` 或 `.o` 文件）。
4. **链接和加载**：生成的二进制文件被链接成可执行文件，供处理器执行。

### 3. 汇编语言的特点

- 汇编语言：
  - 低级、贴近处理器的指令集。
  - 包含诸如 **`add`**、**`mult`** 之类的指令。
  - 通过 **label** 实现跳转和控制流程，但没有像C语言那样的循环结构。
  - **函数**以标签（label）的形式存在，而非明确的函数定义。

## 四、RISC-V指令与程序的转换

### 1. RISC-V的二进制文件

- 在XV6的lab目录中，运行 `make qemu`后，会生成一系列的 `.o` 文件。
  - 这些文件包含处理器可以理解的二进制编码。
  - 编译过程还会生成 **`.asm` 文件**，记录了C代码转换后的汇编代码。

### 2. 汇编语言的角色

- 所有**编译型语言**（如C、C++）最终都会被编译为**汇编语言**。
- **汇编文件**是中间文件，最终由编译器生成的二进制文件被处理器加载执行。

## 五、总结与思考

### 1. C语言到汇编语言的转换流程

- C语言 → 汇编语言 → 二进制文件 → 执行文件
- 汇编语言是编译型语言与处理器之间的**桥梁**，将高层代码翻译为处理器能理解的低级指令。

### 2. 汇编语言的简洁性与局限

- 汇编语言缺乏C语言的结构化特性，控制流程通过**label和跳转**实现。
- 虽然简单，但汇编语言的灵活性使其成为所有编译型语言的基础。

### 3. 实验中的应用

- 在**traps lab**中，学生将直接操作 **trapframe** 和 **栈**，需要理解RISC-V的**汇编语言与指令集**。
- 掌握这些知识有助于学生理解处理器的工作原理，并完成复杂的系统级编程任务。

通过本节课的学习，我们理解了 **C语言转换为汇编语言** 的基本流程，并掌握了 **RISC-V处理器与指令集架构** 的概念。这些知识为学生在实验中操作 **trapframe** 和进行 **栈管理** 打下了坚实的基础。
