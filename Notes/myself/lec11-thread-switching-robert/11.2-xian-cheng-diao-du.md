# 11.2 XV6线程调度

实现内核中的线程系统存在以下挑战：

* 第一个是如何实现线程间的切换。这里停止一个线程的运行并启动另一个线程的过程通常被称为线程调度（Scheduling）。我们将会看到XV6为每个CPU核都创建了一个线程调度器（Scheduler）。
* 第二个挑战是，当你想要实际实现从一个线程切换到另一个线程时，你需要保存并恢复线程的状态，所以需要决定线程的哪些信息是必须保存的，并且在哪保存它们。
* 最后一个挑战是如何处理运算密集型线程（compute bound thread）。对于线程切换，很多直观的实现是由线程自己自愿的保存自己的状态，再让其他的线程运行。但是如果我们有一些程序正在执行一些可能要花费数小时的长时间计算任务，这样的线程并不能自愿的出让CPU给其他的线程运行。所以这里需要能从长时间运行的运算密集型线程撤回对于CPU的控制，将其放置于一边，稍后再运行它。

![](<../.gitbook/assets/image (748).png>)

接下来，我将首先介绍如何处理运算密集型线程。这里的具体实现你们之前或许已经知道了，就是利用定时器中断。在每个CPU核上，都存在一个硬件设备，它会定时产生中断。XV6与其他所有的操作系统一样，将这个中断传输到了内核中。所以即使我们正在用户空间计算π的前100万位，定时器中断仍然能在例如每隔10ms的某个时间触发，并将程序运行的控制权从用户空间代码切换到内核中的中断处理程序（注，因为中断处理程序优先级更高）。哪怕这些用户空间进程并不配合工作（注，也就是用户空间进程一直占用CPU），内核也可以从用户空间进程获取CPU控制权。

位于内核的定时器中断处理程序，会自愿的将CPU出让（yield）给线程调度器，并告诉线程调度器说，你可以让一些其他的线程运行了。这里的出让其实也是一种线程切换，它会保存当前线程的状态，并在稍后恢复。

![](<../.gitbook/assets/image (686).png>)

在之前的课程中，你们已经了解过了中断处理的流程。这里的基本流程是，定时器中断将CPU控制权给到内核，内核再自愿的出让CPU。

这样的处理流程被称为pre-emptive scheduling。pre-emptive的意思是，即使用户代码本身没有出让CPU，定时器中断仍然会将CPU的控制权拿走，并出让给线程调度器。与之相反的是voluntary scheduling。

![](<../.gitbook/assets/image (751).png>)

有趣的是，在XV6和其他的操作系统中，线程调度是这么实现的：定时器中断会强制的将CPU控制权从用户进程给到内核，这里是pre-emptive scheduling，之后内核会代表用户进程（注，实际是内核中用户进程对应的内核线程会代表用户进程出让CPU），使用voluntary scheduling。

在执行线程调度的时候，操作系统需要能区分几类线程：

* 当前在CPU上运行的线程
* 一旦CPU有空闲时间就想要运行在CPU上的线程
* 以及不想运行在CPU上的线程，因为这些线程可能在等待I/O或者其他事件

这里不同的线程是由状态区分，但是实际上线程的完整状态会要复杂的多（注，线程的完整状态包含了程序计数器，寄存器，栈等等）。下面是我们将会看到的一些线程状态：

* RUNNING，线程当前正在某个CPU上运行
* RUNABLE，线程还没有在某个CPU上运行，但是一旦有空闲的CPU就可以运行
* SLEEPING，这节课我们不会介绍，下节课会重点介绍，这个状态意味着线程在等待一些I/O事件，它只会在I/O事件发生了之后运行

![](<../.gitbook/assets/image (784).png>)

今天这节课，我们主要关注RUNNING和RUNABLE这两类线程。前面介绍的定时器中断或者说pre-emptive scheduling，实际上就是将一个RUNNING线程转换成一个RUNABLE线程。通过出让CPU，pre-emptive scheduling将一个正在运行的线程转换成了一个当前不在运行但随时可以再运行的线程。因为当定时器中断触发时，这个线程还在好好的运行着。

对于RUNNING状态下的线程，它的程序计数器和寄存器位于正在运行它的CPU硬件中。而RUNABLE线程，因为并没有CPU与之关联，所以对于每一个RUNABLE线程，当我们将它从RUNNING转变成RUNABLE时，我们需要将它还在RUNNING时位于CPU的状态拷贝到内存中的某个位置，注意这里不是从内存中的某处进行拷贝，而是从CPU中的寄存器拷贝。我们需要拷贝的信息就是程序计数器（Program Counter）和寄存器。

当线程调度器决定要运行一个RUNABLE线程时，这里涉及了很多步骤，但是其中一步是将之前保存的程序计数器和寄存器拷贝回调度器对应的CPU中。





# 11.2 XV6线程调度

本节课介绍了操作系统中线程调度的关键挑战，包括线程切换的机制、状态管理，以及如何处理长时间占用CPU的运算密集型线程。在XV6中，线程调度依赖于**定时器中断**实现的**抢占式调度（pre-emptive scheduling）**，允许系统在用户进程不主动出让CPU时也能强制切换线程。

## 1. 线程调度的挑战

实现线程系统的三个主要挑战：

- **线程切换**：停止当前线程并启动另一个线程的过程称为线程调度（Scheduling）。在XV6中，每个CPU核都拥有一个线程调度器负责线程切换。
- **状态保存与恢复**：切换线程时，需要保存当前线程的状态（程序计数器、寄存器、栈等），以便稍后恢复该线程。
- **运算密集型线程的处理**：运算密集型线程可能会长时间占用CPU，不会主动出让资源。系统需要一种方式强制撤回这些线程的CPU控制权，以保证其他线程的运行。

## 2. 处理运算密集型线程：定时器中断与抢占式调度

XV6中的运算密集型线程处理依赖于定时器中断：

- **定时器中断**：==每个CPU核都配有硬件定时器，定期触发中断，将CPU控制权切换到内核的中断处理程序。即使用户进程在持续运行（如计算π的前百万位），定时器中断仍能定期获取CPU控制权。==
- **抢占式调度（pre-emptive scheduling）**：==通过定时器中断将CPU从用户进程中拿回，并出让（yield）给调度器。调度器随后将控制权分配给其他线程。这种机制在用户进程不主动出让CPU时仍然能够切换线程。==

## 3. 线程状态与调度器的工作机制

==调度器需要管理不同状态的线程，以便高效分配CPU资源。主要的线程状态包括：==

- **RUNNING**：==线程当前正在某个CPU上运行。==
- **RUNABLE**：==线程可以运行，一旦有空闲CPU即可获得资源。==
- **SLEEPING**：==线程正在等待I/O或其他事件（将在后续课程中介绍）。==

定时器中断会将RUNNING线程转换为RUNABLE状态，使其暂停运行。此转换过程涉及保存线程状态，尤其是程序计数器和寄存器的内容。

### 状态保存与恢复

- **保存状态**：==当一个RUNNING线程转换为RUNABLE时，需要将它的程序计数器和寄存器从CPU硬件拷贝到内存中的特定位置，保存其状态。==
- **恢复状态**：当调度器决定再次运行一个RUNABLE线程时，会将其保存的程序计数器和寄存器内容恢复到CPU中，使线程能够继续运行。

------

### 总结

XV6的线程调度系统通过定时器中断实现抢占式调度，确保CPU资源不会被运算密集型线程独占。调度器通过线程状态管理和保存恢复机制实现线程的高效切换，使得多任务执行更加流畅。
