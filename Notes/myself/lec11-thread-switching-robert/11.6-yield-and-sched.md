# 11.6 XV6线程切换 --- yield/sched函数

回到devintr函数返回到usertrap函数中的位置。在gdb里面输入几次step走到yield函数的调用。yield函数是整个线程切换的第一步，下面是yield函数的内容：

![](<../.gitbook/assets/image (663).png>)

yield函数只做了几件事情，它首先获取了进程的锁。实际上，在锁释放之前，进程的状态会变得不一致，例如，yield将要将进程的状态改为RUNABLE，表明进程并没有在运行，但是实际上这个进程还在运行，代码正在当前进程的内核线程中运行。所以这里加锁的目的之一就是：即使我们将进程的状态改为了RUNABLE，其他的CPU核的调度器线程也不可能看到进程的状态为RUNABLE并尝试运行它。否则的话，进程就会在两个CPU核上运行了，而一个进程只有一个栈，这意味着两个CPU核在同一个栈上运行代码（注，因为XV6中一个用户进程只有一个用户线程）。

接下来yield函数中将进程的状态改为RUNABLE。这里的意思是，当前进程要出让CPU，并切换到调度器线程。当前进程的状态是RUNABLE意味着它还会再次运行，因为毕竟现在是一个定时器中断打断了当前正在运行的进程。

之后yield函数中调用了位于proc.c文件中的sched函数。我们进入到sched函数中，

![](<../.gitbook/assets/image (516) (2) (2) (2) (1).png>)

可以看出，sched函数基本没有干任何事情，只是做了一些合理性检查，如果发现异常就panic。为什么会有这么多检查？因为这里的XV6代码已经有很多年的历史了，这些代码经历过各种各样的bug，相应的这里就有各种各样的合理性检查和panic来避免可能的bug。我将跳过所有的检查，直接走到位于底部的swtch函数。





# 11.6 XV6线程切换 --- `yield`和`sched`函数

本节课深入分析了XV6中的`yield`和`sched`函数，这些函数是线程切换的关键部分，确保进程状态的正确性和安全性。

## 1. `yield`函数：出让CPU的第一步

`yield`函数执行线程切换的初步工作，主要步骤如下：

- **获取进程锁**：`yield`函数首先获取当前进程的锁，这是为了避免进程在切换过程中状态不一致。如果未加锁，可能会导致调度器线程在当前进程切换状态前将其误判为RUNABLE并在其他CPU核上运行，造成两个CPU核同时操作同一个栈的情况。
- **设置为RUNABLE状态**：`yield`函数将当前进程的状态改为RUNABLE，表示它出让CPU但稍后仍会被调度执行。当前状态的变更会通知调度器线程该进程可以再次运行。
- **调用`sched`函数**：`yield`函数调用`sched`函数，这是完成线程切换的下一步，负责安全地切换到调度器线程。

## 2. `sched`函数：检查状态并调用`swtch`

`sched`函数的主要任务是执行检查并调用`swtch`函数来完成真正的线程切换：

- **状态检查**：`sched`函数进行多项合理性检查，包括检查当前锁的持有情况、进程状态是否正确等，以确保不会发生错误。由于XV6的代码经历过长期的开发和测试，这些检查有助于避免潜在的bug或不一致性。
- **调用`swtch`函数**：完成状态检查后，`sched`函数调用`swtch`函数，将当前进程的内核线程切换到当前CPU核的调度器线程。调度器线程会选择下一个RUNABLE的进程以继续执行。

------

### 总结

- **`yield`函数**：在出让CPU时先将进程状态设置为RUNABLE，并确保通过锁来防止状态不一致。
- **`sched`函数**：执行进程状态的合理性检查，调用`swtch`完成进程到调度器线程的切换。

通过这两步，XV6的线程切换过程确保了线程状态的正确性和切换的安全性。

