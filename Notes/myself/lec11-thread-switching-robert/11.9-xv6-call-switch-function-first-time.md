# 11.9 XV6线程第一次调用switch函数

（注，首先是学生提问Linux内一个进程多个线程的实现方式，因为在XV6中，一个进程只有一个用户线程）

> 学生提问：操作系统都带了线程的实现，如果想要在多个CPU上运行一个进程内的多个线程，那需要通过操作系统来处理而不是用户空间代码，是吧？那这里的线程切换是怎么工作的？是每个线程都与进程一样了吗？操作系统还会遍历所有存在的线程吗？比如说我们有8个核，每个CPU核都会在多个进程的更多个线程之间切换。同时我们也不想只在一个CPU核上切换一个进程的多个线程，是吧？
>
> Robert教授：Linux是支持一个进程包含多个线程，Linux的实现比较复杂，或许最简单的解释方式是：几乎可以认为Linux中的每个线程都是一个完整的进程。Linux中，我们平常说一个进程中的多个线程，本质上是共享同一块内存的多个独立进程。所以Linux中一个进程的多个线程仍然是通过一个内存地址空间执行代码。如果你在一个进程创建了2个线程，那基本上是2个进程共享一个地址空间。之后，调度就与XV6是一致的，也就是针对每个进程进行调度。
>
> 学生提问：用户可以指定将线程绑定在某个CPU上吗？操作系统如何确保一个进程的多个线程不会运行在同一个CPU核上？要不然就违背了多线程的初衷了。
>
> Robert教授：这里其实与XV6非常相似，假设有4个CPU核，Linux会找到4件事情运行在这4个核上。如果并没有太多正在运行的程序的话，或许会将一个进程的4个线程运行在4个核上。或者如果有100个用户登录在Athena机器上，内核会随机为每个CPU核找到一些事情做。
>
> 如果你想做一些精细的测试，有一些方法可以将线程绑定在CPU核上，但正常情况下人们不会这么做。
>
> 学生提问：所以说一个进程中的多个线程会有相同的page table？
>
> Robert教授：是的，如果你在Linux上，你为一个进程创建了2个线程，我不确定它们是不是共享同一个的page table，还是说它们是不同的page table，但是内容是相同的。
>
> 学生提问：有没有原因说这里的page table要是分开的？
>
> Robert教授：我不知道Linux究竟用了哪种方法。

（注，以下是线程第一次调用switch的过程）

> 学生提问：当调用swtch函数的时候，实际上是从一个线程对于switch的调用切换到了另一个线程对于switch的调用。所以线程第一次调用swtch函数时，需要伪造一个“另一个线程”对于switch的调用，是吧？因为也不能通过swtch函数随机跳到其他代码去。
>
> Robert教授：是的。我们来看一下第一次调用switch时，“另一个”调用swtch函数的线程的context对象。proc.c文件中的allocproc函数会被启动时的第一个进程和fork调用，allocproc会设置好新进程的context，如下所示：

![](<../.gitbook/assets/image (442).png>)

> 实际上大部分寄存器的内容都无所谓。但是ra很重要，因为这是进程的第一个switch调用会返回的位置。同时因为进程需要有自己的栈，所以ra和sp都被设置了。这里设置的forkret函数就是进程的第一次调用swtch函数会切换到的“另一个”线程位置。
>
> 学生提问：所以当swtch函数返回时，CPU会执行forkret中的指令，就像forkret刚刚调用了swtch函数并且返回了一样？
>
> Robert教授：是的，从switch返回就直接跳到了forkret的最开始位置。
>
> 学生提问：因吹斯听，我们会在其他场合调用forkret吗？还是说它只会用在这？
>
> Robert教授：是的，它只会在启动进程的时候以这种奇怪的方式运行。下面是forkret函数的代码，

![](<../.gitbook/assets/image (422).png>)

> 从代码中看，它的工作其实就是释放调度器之前获取的锁。函数最后的usertrapret函数其实也是一个假的函数，它会使得程序表现的看起来像是从trap中返回，但是对应的trapframe其实也是假的，这样才能跳到用户的第一个指令中。
>
> 学生提问：与之前的context对象类似的是，对于trapframe也不用初始化任何寄存器，因为我们要去的是程序的最开始，所以不需要做任何假设，对吧？
>
> Robert教授：我认为程序计数器还是要被初始化为0的。

![](<../.gitbook/assets/image (512).png>)

> 因为fork拷贝的进程会同时拷贝父进程的程序计数器，所以我们唯一不是通过fork创建进程的场景就是创建第一个进程的时候。这时需要设置程序计数器为0。
>
> 学生提问：在fortret函数中，if(first)是什么意思？
>
> Robert教授：文件系统需要被初始化，具体来说，需要从磁盘读取一些数据来确保文件系统的运行，比如说文件系统究竟有多大，各种各样的东西在文件系统的哪个位置，同时还需要有crash recovery log。完成任何文件系统的操作都需要等待磁盘操作结束，但是XV6只能在进程的context下执行文件系统操作，比如等待I/O。所以初始化文件系统需要等到我们有了一个进程才能进行。而这一步是在第一次调用forkret时完成的，所以在forkret中才有了if(first)判断。





# 11.9 XV6线程第一次调用`switch`函数

在XV6中，`swtch`函数用于从一个线程切换到另一个线程，它会返回到目标线程的`ra`（return address）寄存器中保存的地址。然而在首次调用时，目标线程还没有实际调用过`swtch`函数，因此需要一个伪造的返回地址，以确保切换顺利进行。

## 1. 初次调用`switch`的伪造上下文

在XV6的`allocproc`函数中，为新创建的进程准备了第一个context对象，其中将`ra`寄存器设为`forkret`函数的地址。这确保了`swtch`第一次调用后会跳转到`forkret`函数中执行，使进程启动。

### `allocproc`中的伪造context

```
c复制代码p->context.ra = (uint64)forkret;   // 设置ra返回地址
p->context.sp = p->kstack + PGSIZE; // 设置sp为进程的内核栈顶
```

此设置保证了当进程的内核线程首次调用`swtch`时，它会返回到`forkret`，并且新进程会从这里开始执行。

## 2. `forkret`函数：释放锁和跳转到用户态

`forkret`函数的主要作用是释放调度器的锁，确保系统资源的正常释放和进程的独立运行。

```
c复制代码void forkret() {
  release(&p->lock);  // 释放调度器锁
  usertrapret();      // 准备从trap返回到用户态
}
```

在此代码中：

- `release(&p->lock)`用于确保调度器线程释放调度器锁，这样其他进程或线程可以自由访问调度器资源。
- `usertrapret()`模拟从trap返回到用户空间，恢复进程的状态并跳转到用户态执行。这是一个虚拟的trap返回流程，通过加载程序计数器和其他寄存器，将进程引导至用户代码的第一条指令。

## 3. `usertrapret`的初始化

每个新进程的trapframe中需要设置好程序计数器，确保它能从正确的起点开始执行代码。

```
c


复制代码
p->trapframe->epc = 0; // 设置程序计数器为用户程序的起点
```

对于系统中的第一个用户进程，`epc`会被初始化为起始位置0。这是因为第一个进程没有父进程，所以需要手动设置。

## 总结

- **初次调用的context伪造**：通过在`allocproc`中将`ra`寄存器设为`forkret`，XV6能顺利启动新进程。
- **`forkret`的作用**：释放调度器锁并跳转到用户态，确保资源释放和进程独立运行。
- **用户态初始化**：为第一个用户进程的trapframe设置初始程序计数器，使其从0开始运行。

这些初始设置确保了XV6可以在首次启动时顺利从内核切换到第一个用户进程。
