# 11.8 XV6线程切换 --- scheduler函数

来看一下scheduler的完整代码，

![](<../.gitbook/assets/image (565) (2).png>)

现在我们正运行在CPU拥有的调度器线程中，并且我们正好在之前调用swtch函数的返回状态。之前调度器线程调用switch是因为想要运行pid为3的进程，也就是刚刚被中断的spin程序。

虽然pid为3的spin进程也调用了swtch函数，但是那个switch并不是当前返回的这个switch。spin进程调用的swtch函数还没有返回，而是保存在了pid为3的栈和context对象中。现在返回的是之前调度器线程对于swtch函数的调用。

在scheduler函数中，因为我们已经停止了spin进程的运行，所以我们需要抹去对于spin进程的记录。我们接下来将c->proc设置为0（c->proc = 0;）。因为我们现在并没有在这个CPU核上运行这个进程，为了不让任何人感到困惑，我们这里将CPU核运行的进程对象设置为0。

之前在yield函数中获取了进程的锁，因为yield不想进程完全进入到Sleep状态之前，任何其他的CPU核的调度器线程看到这个进程并运行它。而现在我们完成了从spin进程切换走，所以现在可以释放锁了。这就是release(\&p->lock)的意义。现在，我们仍然在scheduler函数中，但是其他的CPU核可以找到spin进程，并且因为spin进程是RUNABLE状态，其他的CPU可以运行它。这没有问题，因为我们已经完整的保存了spin进程的寄存器，并且我们不在spin进程的栈上运行程序，而是在当前CPU核的调度器线程栈上运行程序，所以其他的CPU核运行spin程序并没有问题。但是因为启动QEMU时我们只指定了一个核，所以在我们现在的演示中并没有其他的CPU核来运行spin程序。

接下来我将简单介绍一下p->lock。从调度的角度来说，这里的锁完成了两件事情。

首先，出让CPU涉及到很多步骤，我们需要将进程的状态从RUNNING改成RUNABLE，我们需要将进程的寄存器保存在context对象中，并且我们还需要停止使用当前进程的栈。所以这里至少有三个步骤，而这三个步骤需要花费一些时间。所以锁的第一个工作就是在这三个步骤完成之前，阻止任何一个其他核的调度器线程看到当前进程。锁这里确保了三个步骤的原子性。从CPU核的角度来说，三个步骤要么全发生，要么全不发生。

第二，当我们开始要运行一个进程时，p->lock也有类似的保护功能。当我们要运行一个进程时，我们需要将进程的状态设置为RUNNING，我们需要将进程的context移到RISC-V的寄存器中。但是，如果在这个过程中，发生了中断，从中断的角度来说进程将会处于一个奇怪的状态。比如说进程的状态是RUNNING，但是又还没有将所有的寄存器从context对象拷贝到RISC-V寄存器中。所以，如果这时候有了一个定时器中断将会是个灾难，因为我们可能在寄存器完全恢复之前，从这个进程中切换走。而从这个进程切换走的过程中，将会保存不完整的RISC-V寄存器到进程的context对象中。所以我们希望启动一个进程的过程也具有原子性。在这种情况下，切换到一个进程的过程中，也需要获取进程的锁以确保其他的CPU核不能看到这个进程。同时在切换到进程的过程中，还需要关闭中断，这样可以避免定时器中断看到还在切换过程中的进程。（注，这就是为什么468行需要加锁的原因）

现在我们在scheduler函数的循环中，代码会检查所有的进程并找到一个来运行。现在我们知道还有另一个进程，因为我们之前fork了另一个spin进程。这里我跳过进程检查，直接在找到RUNABLE进程的位置设置一个断点。

![](<../.gitbook/assets/image (458).png>)

在代码的468行，获取了进程的锁，所以现在我们可以进行切换到进程的各种步骤。在代码的473行，进程的状态被设置成了RUNNING。代码的474行将找到的RUNABLE进程记录为当前CPU执行的进程。代码的475行，又调用了swtch函数来保存调度器线程的寄存器，并恢复目标进程的寄存器（注，实际上恢复的是目标进程的内核线程）。我们可以打印新的进程的名字来查看新的进程。

![](<../.gitbook/assets/image (567).png>)

可以看到进程名还是spin，但是pid已经变成了4，而前一个进程的pid是3。我们还可以查看目标进程的context对象，

![](<../.gitbook/assets/image (623).png>)

其中ra寄存器的内容就是我们要切换到的目标线程的代码位置。虽然我们在代码475行调用的是swtch函数，但是我们前面已经看过了swtch函数会返回到即将恢复的ra寄存器地址，所以我们真正关心的就是ra指向的地址。

![](<../.gitbook/assets/image (564).png>)

通过打印这个地址的内容，可以看到swtch函数会返回到sched函数中。这完全在意料之中，因为可以预期的是，将要切换到的进程之前是被定时器中断通过sched函数挂起的，并且之前在sched函数中又调用了swtch函数。

在swtch函数的最开始，我们仍然在调度器线程中，但是这一次是从调度器线程切换到目标进程的内核线程。所以从swtch函数内部将会返回到目标进程的内核线程的sched函数，通过打印backtrace，

![](<../.gitbook/assets/image (441).png>)

我们可以看到，之前有一个usertrap的调用，这必然是之前因为定时器中断而出现的调用。之后在中断处理函数中还调用了yield和sched函数，正如我们之前看到的一样。但是，这里调用yield和sched函数是在pid为4的进程调用的，而不是我们刚刚看的pid为3的进程。

> 学生提问：如果不是因为定时器中断发生的切换，我们是不是可以期望ra寄存器指向其他位置，例如sleep函数？
>
> Robert教授：是的，我们之前看到了代码执行到这里会包含一些系统调用相关的函数。你基本上回答了自己的问题，如果我们因为定时器中断之外的原因而停止了执行当前的进程，switch会返回到一些系统调用的代码中，而不是我们这里看到sched函数。我记得sleep最后也调用了sched函数，虽然bracktrace可能看起来会不一样，但是还是会包含sched。所以我这里只介绍了一种进程间切换的方法，也就是因为定时器中断而发生切换。但是还有其他的可能会触发进程切换，例如等待I/O或者等待另一个进程向pipe写数据。

这里有件事情需要注意，调度器线程调用了swtch函数，但是我们从swtch函数返回时，实际上是返回到了对于switch的另一个调用，而不是调度器线程中的调用。我们返回到的是pid为4的进程在很久之前对于switch的调用。这里可能会有点让人困惑，但是这就是线程切换的核心。

另一件需要注意的事情是，swtch函数是线程切换的核心，但是swtch函数中只有保存寄存器，再加载寄存器的操作。线程除了寄存器以外的还有很多其他状态，它有变量，堆中的数据等等，但是所有的这些数据都在内存中，并且会保持不变。我们没有改变线程的任何栈或者堆数据。所以线程切换的过程中，处理器中的寄存器是唯一的不稳定状态，且需要保存并恢复。而所有其他在内存中的数据会保存在内存中不被改变，所以不用特意保存并恢复。我们只是保存并恢复了处理器中的寄存器，因为我们想在新的线程中也使用相同的一组寄存器。





# 11.8 XV6线程切换 —— `scheduler`函数

本节课程讲解了`scheduler`函数，它负责在各个进程之间进行切换，使每个RUNABLE状态的进程都能够被分配到CPU运行。

## 1. `scheduler`函数的主要流程

`scheduler`函数在调度器线程的上下文中运行，当调用`swtch`函数返回时，它会选择一个RUNABLE状态的进程进行切换。当前调度器线程是在调度器的context上运行的，因为之前在`swtch`中从目标进程切换回来。

### 代码中的关键步骤

1. **重置当前CPU的进程记录**：`c->proc = 0;` 清除CPU上正在运行的进程的记录。当前CPU不再运行原进程，因此需要将其置空，以确保其他CPU不会错误地认为该进程正在此CPU上运行。
2. **释放原进程的锁**：通过`release(&p->lock);` 释放当前进程的锁，以便其他CPU或调度器线程可以将该进程标记为RUNABLE并调度运行。
3. **进入调度循环**：进入循环，遍历所有进程，查找状态为RUNABLE的进程并进行调度。在实际操作系统中，这个调度算法可能更复杂，但XV6中主要按顺序查找。
4. **锁定新进程并切换状态**：在找到一个RUNABLE进程后，代码会将该进程状态更新为RUNNING，并在`c->proc`中记录新进程作为当前CPU的进程。
5. **调用`swtch`切换到新进程**：最后，`scheduler`调用`swtch`函数，将当前的调度器线程切换到新选中的进程。`swtch`会保存调度器的状态，并加载目标进程的context，完成真正的切换。

## 2. `p->lock`的作用

在`scheduler`和进程调度中，`p->lock`用于保证调度切换过程中的原子性和一致性：

- **在进程切换过程中防止并发问题**：锁定进程对象，确保在切换过程中，其他调度器线程不会尝试调度该进程，避免同时修改进程状态。
- **保护切换过程中状态的原子性**：如前所述，切换过程包含多个步骤。锁保护这些步骤，使其不会被打断。

## 3. 使用`swtch`切换到目标进程

`swtch`函数会将调度器线程的寄存器保存到调度器context，并恢复目标进程的寄存器，切换到目标进程的内核线程。

- **ra寄存器**：在恢复时，`ra`寄存器记录的是目标进程的代码位置，通过查阅内存和代码，我们可以确认它指向`yield`或`sched`，这表明上一次切换是在中断或系统调用时发生的。

## 4. 栈和堆的数据保持不变

在`swtch`中，唯一需要保存和恢复的是处理器的寄存器，而进程的栈和堆数据仍然保留在内存中不变。每个进程都有各自的栈空间，栈内容在进程切换期间保持不变，确保线程在恢复时可以继续使用相同的栈和堆数据。

------

### 总结

- `scheduler`函数在CPU的调度器线程中循环执行，查找RUNABLE进程并调用`swtch`函数切换到目标进程。
- `p->lock`确保进程切换的原子性，防止其他线程在切换过程中打断。
- `swtch`函数实现了调度器线程到目标进程的寄存器切换，仅需保存和恢复寄存器，而栈和堆数据保持不变，确保切换后的进程能够正常恢复执行。
